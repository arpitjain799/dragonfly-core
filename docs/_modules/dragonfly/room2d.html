<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dragonfly.room2d &#8212; dragonfly-core  documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          dragonfly-core</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli/index.html">CLI Docs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../cli/index.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cli/index.html#commands">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../cli/translate.html">translate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate">dragonfly translate</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-merge-models-to-honeybee">merge-models-to-honeybee</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-model-from-geojson">model-from-geojson</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-model-to-honeybee">model-to-honeybee</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-model-to-honeybee-file">model-to-honeybee-file</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../cli/edit.html">edit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit">dragonfly edit</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-align">align</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-convert-units">convert-units</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-remove-short-segments">remove-short-segments</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-reset-room-boundaries">reset-room-boundaries</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-solve-adjacency">solve-adjacency</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-windows-by-ratio">windows-by-ratio</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../cli/create.html">create</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/create.html#dragonfly-create">dragonfly create</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/create.html#dragonfly-create-merge-models">merge-models</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../cli/validate.html">validate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/validate.html#dragonfly-validate">dragonfly validate</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/validate.html#dragonfly-validate-model">model</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">dragonfly</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../dragonfly.html">dragonfly package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../dragonfly.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.cli.html">dragonfly.cli package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.cli.html#submodules">Submodules</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.create.html">dragonfly.cli.create module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.edit.html">dragonfly.cli.edit module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.translate.html">dragonfly.cli.translate module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.validate.html">dragonfly.cli.validate module</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.cli.html#module-dragonfly.cli">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.writer.html">dragonfly.writer package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.writer.html#submodules">Submodules</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.building.html">dragonfly.writer.building module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.context.html">dragonfly.writer.context module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.model.html">dragonfly.writer.model module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.room2d.html">dragonfly.writer.room2d module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.story.html">dragonfly.writer.story module</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.writer.html#module-dragonfly.writer">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../dragonfly.html#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.building.html">dragonfly.building module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.colorobj.html">dragonfly.colorobj module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.config.html">dragonfly.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.context.html">dragonfly.context module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.dictutil.html">dragonfly.dictutil module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.extensionutil.html">dragonfly.extensionutil module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.model.html">dragonfly.model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.projection.html">dragonfly.projection module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.properties.html">dragonfly.properties module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.roof.html">dragonfly.roof module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.room2d.html">dragonfly.room2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.shadingparameter.html">dragonfly.shadingparameter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.skylightparameter.html">dragonfly.skylightparameter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.story.html">dragonfly.story module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.subdivide.html">dragonfly.subdivide module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.windowparameter.html">dragonfly.windowparameter module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../dragonfly.html#module-dragonfly">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli/index.html">CLI Docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">dragonfly</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-4">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli/index.html">CLI Docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">dragonfly</a></li>
</ul>

        </div>
      </div>
    <div class="body col-md-8 content" role="main">
      
  <h1>Source code for dragonfly.room2d</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;Dragonfly Room2D.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">ladybug_geometry.geometry2d</span> <span class="kn">import</span> <span class="n">Point2D</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="n">Ray2D</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">,</span> \
    <span class="n">Polygon2D</span>
<span class="kn">from</span> <span class="nn">ladybug_geometry.geometry3d</span> <span class="kn">import</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">,</span> <span class="n">Ray3D</span><span class="p">,</span> <span class="n">LineSegment3D</span><span class="p">,</span> \
    <span class="n">Plane</span><span class="p">,</span> <span class="n">Polyline3D</span><span class="p">,</span> <span class="n">Face3D</span><span class="p">,</span> <span class="n">Polyface3D</span>
<span class="kn">from</span> <span class="nn">ladybug_geometry.intersection2d</span> <span class="kn">import</span> <span class="n">closest_point2d_between_line2d</span>
<span class="kn">from</span> <span class="nn">ladybug_geometry.intersection3d</span> <span class="kn">import</span> <span class="n">closest_point3d_on_line3d</span><span class="p">,</span> \
    <span class="n">closest_point3d_on_line3d_infinite</span>
<span class="kn">import</span> <span class="nn">ladybug_geometry.boolean</span> <span class="k">as</span> <span class="nn">pb</span>

<span class="kn">from</span> <span class="nn">honeybee.typing</span> <span class="kn">import</span> <span class="n">float_positive</span><span class="p">,</span> <span class="n">clean_string</span><span class="p">,</span> <span class="n">clean_and_id_string</span>
<span class="kn">import</span> <span class="nn">honeybee.boundarycondition</span> <span class="k">as</span> <span class="nn">hbc</span>
<span class="kn">from</span> <span class="nn">honeybee.boundarycondition</span> <span class="kn">import</span> <span class="n">boundary_conditions</span> <span class="k">as</span> <span class="n">bcs</span>
<span class="kn">from</span> <span class="nn">honeybee.boundarycondition</span> <span class="kn">import</span> <span class="n">_BoundaryCondition</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">,</span> <span class="n">Ground</span>
<span class="kn">from</span> <span class="nn">honeybee.facetype</span> <span class="kn">import</span> <span class="n">Floor</span><span class="p">,</span> <span class="n">Wall</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">,</span> <span class="n">RoofCeiling</span>
<span class="kn">from</span> <span class="nn">honeybee.facetype</span> <span class="kn">import</span> <span class="n">face_types</span> <span class="k">as</span> <span class="n">ftyp</span>
<span class="kn">from</span> <span class="nn">honeybee.door</span> <span class="kn">import</span> <span class="n">Door</span>
<span class="kn">from</span> <span class="nn">honeybee.face</span> <span class="kn">import</span> <span class="n">Face</span>
<span class="kn">from</span> <span class="nn">honeybee.room</span> <span class="kn">import</span> <span class="n">Room</span>

<span class="kn">from</span> <span class="nn">._base</span> <span class="kn">import</span> <span class="n">_BaseGeometry</span>
<span class="kn">from</span> <span class="nn">.properties</span> <span class="kn">import</span> <span class="n">Room2DProperties</span>
<span class="kn">import</span> <span class="nn">dragonfly.windowparameter</span> <span class="k">as</span> <span class="nn">glzpar</span>
<span class="kn">from</span> <span class="nn">dragonfly.windowparameter</span> <span class="kn">import</span> <span class="n">_WindowParameterBase</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">,</span> \
    <span class="n">SimpleWindowRatio</span><span class="p">,</span> <span class="n">RectangularWindows</span><span class="p">,</span> <span class="n">DetailedWindows</span>
<span class="kn">import</span> <span class="nn">dragonfly.skylightparameter</span> <span class="k">as</span> <span class="nn">skypar</span>
<span class="kn">from</span> <span class="nn">dragonfly.skylightparameter</span> <span class="kn">import</span> <span class="n">_SkylightParameterBase</span><span class="p">,</span> <span class="n">DetailedSkylights</span>
<span class="kn">import</span> <span class="nn">dragonfly.shadingparameter</span> <span class="k">as</span> <span class="nn">shdpar</span>
<span class="kn">from</span> <span class="nn">dragonfly.shadingparameter</span> <span class="kn">import</span> <span class="n">_ShadingParameterBase</span>
<span class="kn">import</span> <span class="nn">dragonfly.writer.room2d</span> <span class="k">as</span> <span class="nn">writer</span>


<div class="viewcode-block" id="Room2D"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D">[docs]</a><span class="k">class</span> <span class="nc">Room2D</span><span class="p">(</span><span class="n">_BaseGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A volume defined by an extruded floor plate, representing a single room or space.</span>

<span class="sd">    Args:</span>
<span class="sd">        identifier: Text string for a unique Room2D ID. Must be &lt; 100 characters and</span>
<span class="sd">            not contain any spaces or special characters.</span>
<span class="sd">        floor_geometry: A single horizontal Face3D object representing the</span>
<span class="sd">            floor plate of the Room. Note that this Face3D must be horizontal</span>
<span class="sd">            to be valid.</span>
<span class="sd">        floor_to_ceiling_height: A number for the height above the floor where the</span>
<span class="sd">            ceiling begins. This should be in the same units system as the input</span>
<span class="sd">            floor_geometry. Typical values range from 3 to 5 meters.</span>
<span class="sd">        boundary_conditions: A list of boundary conditions that match the number of</span>
<span class="sd">            segments in the input floor_geometry. These will be used to assign</span>
<span class="sd">            boundary conditions to each of the walls of the Room in the resulting</span>
<span class="sd">            model. If None, all boundary conditions will be Outdoors or Ground</span>
<span class="sd">            depending on whether ceiling of the room is below 0 (the assumed</span>
<span class="sd">            ground plane). Default: None.</span>
<span class="sd">        window_parameters: A list of WindowParameter objects that dictate how the</span>
<span class="sd">            window geometries will be generated for each of the walls. If None,</span>
<span class="sd">            no windows will exist over the entire Room2D. Default: None.</span>
<span class="sd">        shading_parameters: A list of ShadingParameter objects that dictate how the</span>
<span class="sd">            shade geometries will be generated for each of the walls. If None,</span>
<span class="sd">            no shades will exist over the entire Room2D. Default: None.</span>
<span class="sd">        is_ground_contact: A boolean noting whether this Room2D has its floor</span>
<span class="sd">            in contact with the ground. Default: False.</span>
<span class="sd">        is_top_exposed: A boolean noting whether this Room2D has its ceiling</span>
<span class="sd">            exposed to the outdoors. Default: False.</span>
<span class="sd">        tolerance: The maximum difference between z values at which point vertices</span>
<span class="sd">            are considered to be in the same horizontal plane. This is used to check</span>
<span class="sd">            that all vertices of the input floor_geometry lie in the same horizontal</span>
<span class="sd">            floor plane. Default is 0, which will not perform any check.</span>

<span class="sd">    Properties:</span>
<span class="sd">        * identifier</span>
<span class="sd">        * display_name</span>
<span class="sd">        * floor_geometry</span>
<span class="sd">        * floor_to_ceiling_height</span>
<span class="sd">        * boundary_conditions</span>
<span class="sd">        * window_parameters</span>
<span class="sd">        * shading_parameters</span>
<span class="sd">        * air_boundaries</span>
<span class="sd">        * is_ground_contact</span>
<span class="sd">        * is_top_exposed</span>
<span class="sd">        * skylight_parameters</span>
<span class="sd">        * parent</span>
<span class="sd">        * has_parent</span>
<span class="sd">        * floor_segments</span>
<span class="sd">        * floor_segments_2d</span>
<span class="sd">        * segment_count</span>
<span class="sd">        * segment_normals</span>
<span class="sd">        * floor_height</span>
<span class="sd">        * ceiling_height</span>
<span class="sd">        * volume</span>
<span class="sd">        * floor_area</span>
<span class="sd">        * exterior_wall_area</span>
<span class="sd">        * exterior_aperture_area</span>
<span class="sd">        * is_core</span>
<span class="sd">        * is_perimeter</span>
<span class="sd">        * min</span>
<span class="sd">        * max</span>
<span class="sd">        * center</span>
<span class="sd">        * user_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_floor_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;_segment_count&#39;</span><span class="p">,</span> <span class="s1">&#39;_floor_to_ceiling_height&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_boundary_conditions&#39;</span><span class="p">,</span> <span class="s1">&#39;_window_parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;_shading_parameters&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_air_boundaries&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_ground_contact&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_top_exposed&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_skylight_parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;_parent&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">floor_geometry</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                 <span class="n">boundary_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shading_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A volume defined by an extruded floor plate, representing a single room.&quot;&quot;&quot;</span>
        <span class="n">_BaseGeometry</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>  <span class="c1"># process the identifier</span>

        <span class="c1"># process the floor_geometry</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">Face3D</span><span class="p">),</span> \
            <span class="s1">&#39;Expected ladybug_geometry Face3D. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">floor_geometry</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">floor_geometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="c1"># ensure a global 2D origin, which helps in solve adjacency and the dict schema</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span>
                                      <span class="n">o_pl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="c1"># check that the floor_geometry lies in the same horizontal plane.</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">,</span> <span class="s1">&#39;Not all of Room2D &#39;</span> \
                <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; vertices lie within the same horizontal plane.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>

        <span class="c1"># process segment count and floor-to-ceiling height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">floor_to_ceiling_height</span>

        <span class="c1"># process the boundary conditions</span>
        <span class="k">if</span> <span class="n">boundary_conditions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span>
                <span class="n">boundary_conditions</span><span class="p">,</span> <span class="s1">&#39;boundary_conditions&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundaryCondition</span><span class="p">),</span> \
                    <span class="s1">&#39;Expected BoundaryCondition. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># process the window and shading parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">window_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shading_parameters</span> <span class="o">=</span> <span class="n">shading_parameters</span>

        <span class="c1"># ensure all wall-assigned objects align with the geometry if it has been flipped</span>
        <span class="k">if</span> <span class="n">floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win_pars</span><span class="p">,</span> <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_flip_wall_assigned_objects</span><span class="p">(</span>
                <span class="n">floor_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd_pars</span>

        <span class="c1"># process the top and bottom exposure properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span> <span class="o">=</span> <span class="n">is_ground_contact</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="o">=</span> <span class="n">is_top_exposed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be set if it&#39;s ever used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># _parent will be set when Room2D is added to a Story</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="n">Room2DProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># properties for extensions</span>

<div class="viewcode-block" id="Room2D.from_dict"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Room2D from a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: A dictionary representation of a Room2D object.</span>
<span class="sd">            tolerance: The maximum difference between z values at which point vertices</span>
<span class="sd">                are considered to be in the same horizontal plane. This is used to check</span>
<span class="sd">                that all vertices of the input floor_geometry lie in the same horizontal</span>
<span class="sd">                floor plane. Default is 0, which will not perform any check.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the type of dictionary</span>
        <span class="k">assert</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Room2D&#39;</span><span class="p">,</span> <span class="s1">&#39;Expected Room2D dictionary. &#39;</span> \
            <span class="s1">&#39;Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>

        <span class="c1"># re-assemble the floor_geometry</span>
        <span class="n">bound_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_height&#39;</span><span class="p">])</span>
                       <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_boundary&#39;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="s1">&#39;floor_holes&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">hole_verts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_height&#39;</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_holes&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hole_verts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">hole_verts</span><span class="p">)</span>

        <span class="c1"># re-assemble boundary conditions</span>
        <span class="k">if</span> <span class="s1">&#39;boundary_conditions&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;boundary_conditions&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b_conditions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bc_dict</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;boundary_conditions&#39;</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bc_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hbc</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Boundary condition &quot;</span><span class="si">{}</span><span class="s1">&quot; is not supported in this honeybee &#39;</span>
                        <span class="s1">&#39;installation.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bc_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
                <span class="n">b_conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">bc_dict</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b_conditions</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># re-assemble window parameters</span>
        <span class="k">if</span> <span class="s1">&#39;window_parameters&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">glz_pars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">glz_dict</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">glz_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">glz_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;DetailedWindows&#39;</span><span class="p">:</span>
                        <span class="n">segment</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">floor_segment_by_index</span><span class="p">(</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">glz_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">glz_dict</span><span class="p">,</span> <span class="n">segment</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">glz_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">glzpar</span><span class="p">,</span> <span class="n">glz_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s1">&#39;Window parameter &quot;</span><span class="si">{}</span><span class="s1">&quot; is not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">glz_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
                        <span class="n">glz_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">glz_dict</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">glz_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glz_pars</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># re-assemble shading parameters</span>
        <span class="k">if</span> <span class="s1">&#39;shading_parameters&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shd_pars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shd_dict</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">shd_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">shd_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">shdpar</span><span class="p">,</span> <span class="n">shd_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Shading parameter &quot;</span><span class="si">{}</span><span class="s1">&quot; is not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">shd_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
                    <span class="n">shd_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">shd_dict</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shd_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shd_pars</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># get the top and bottom exposure properties</span>
        <span class="n">grnd</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;is_ground_contact&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;is_ground_contact&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;is_top_exposed&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;is_top_exposed&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># create the Room2D object</span>
        <span class="n">room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;identifier&#39;</span><span class="p">],</span> <span class="n">floor_geometry</span><span class="p">,</span>
                      <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_to_ceiling_height&#39;</span><span class="p">],</span>
                      <span class="n">b_conditions</span><span class="p">,</span> <span class="n">glz_pars</span><span class="p">,</span> <span class="n">shd_pars</span><span class="p">,</span> <span class="n">grnd</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># assign any skylight parameters if they are specified</span>
        <span class="k">if</span> <span class="s1">&#39;skylight_parameters&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sky_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">skypar</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Skylight parameter &quot;</span><span class="si">{}</span><span class="s1">&quot; is not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
            <span class="n">room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">sky_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">])</span>

        <span class="c1"># set all of the other optional properties</span>
        <span class="k">if</span> <span class="s1">&#39;air_boundaries&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;air_boundaries&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;air_boundaries&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;display_name&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;display_name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;display_name&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;user_data&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;user_data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;user_data&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Room2DProperties&#39;</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">_load_extension_attr_from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">room</span></div>

<div class="viewcode-block" id="Room2D.from_honeybee"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_honeybee">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_honeybee</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Room2D from a Honeybee Room.</span>

<span class="sd">        Note that Dragonfly Room2Ds are abstractions of Honeybee Rooms and there</span>
<span class="sd">        will be loss of information if the Honeybee Room is not an extruded floor</span>
<span class="sd">        plate or if extension properties are assigned to individual Faces</span>
<span class="sd">        or Apertures instead of at the Room level.</span>

<span class="sd">        If the Honeybee Room contains no Floor Faces, None will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            room: A Honeybee Room object.</span>
<span class="sd">            tolerance: The maximum difference between values at which point vertices</span>
<span class="sd">                are considered to be the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first extract the room polygon from the joined floor faces</span>
        <span class="n">flr_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">geometry</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">Floor</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flr_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">flr_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">flr_geo</span> <span class="o">=</span> <span class="n">flr_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flr_geos</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">join_floor_geometries</span><span class="p">(</span>
                <span class="n">flr_faces</span><span class="p">,</span> <span class="n">room</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="c1"># TODO: consider returning multiple Room2Ds if there&#39;s more than one floor</span>
            <span class="n">flr_geo</span> <span class="o">=</span> <span class="n">flr_geos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">flr_geo</span> <span class="o">=</span> <span class="n">flr_geo</span> <span class="k">if</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>

        <span class="c1"># match the segments of the floor geometry to walls of the Room</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="n">flr_geo</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>
        <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">window_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">air_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>
            <span class="n">wall_f</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_segment_wall_face</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wall_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">boundary_condition</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">_apertures</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">_doors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sf_objs</span> <span class="o">=</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">_apertures</span> <span class="o">+</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">_doors</span>
                    <span class="n">w_geos</span> <span class="o">=</span> <span class="p">[</span><span class="n">sf</span><span class="o">.</span><span class="n">geometry</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sf_objs</span><span class="p">]</span>
                    <span class="n">is_drs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">Door</span><span class="p">)</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sf_objs</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">:</span>  <span class="c1"># vertical wall</span>
                        <span class="n">window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_face3ds</span><span class="p">(</span>
                            <span class="n">w_geos</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">is_drs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># angled wall; scale the Y to covert to vertical</span>
                        <span class="n">w_p</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">w3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">w_p</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">w_p</span><span class="o">.</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>
                               <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">w_geos</span><span class="p">]</span>
                        <span class="n">window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_face3ds</span><span class="p">(</span>
                            <span class="n">w3d</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">is_drs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">):</span>
                    <span class="n">air_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># determine the ceiling height, and top/bottom boundary conditions</span>
        <span class="n">floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">room</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span>
        <span class="n">is_ground_contact</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="n">Ground</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">Floor</span><span class="p">)])</span>
        <span class="n">is_top_exposed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">RoofCeiling</span><span class="p">)])</span>

        <span class="c1"># create the Dragonfly Room2D</span>
        <span class="n">room_2d</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">room</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">flr_geo</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
            <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">window_parameters</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># check if there are any skylights to be added</span>
        <span class="n">skylights</span><span class="p">,</span> <span class="n">are_doors</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">RoofCeiling</span><span class="p">):</span>
                <span class="n">sf_objs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_apertures</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">_doors</span>
                <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sf_objs</span><span class="p">:</span>
                    <span class="n">verts2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
                    <span class="n">skylights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon2D</span><span class="p">(</span><span class="n">verts2d</span><span class="p">))</span>
                    <span class="n">are_doors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">Door</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skylights</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">room_2d</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">DetailedSkylights</span><span class="p">(</span><span class="n">skylights</span><span class="p">,</span> <span class="n">are_doors</span><span class="p">)</span>

        <span class="c1"># add the extra optional attributes</span>
        <span class="n">final_ab</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">air_bounds</span><span class="p">,</span> <span class="n">room_2d</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="n">v_f</span> <span class="o">=</span> <span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="n">final_ab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_f</span><span class="p">)</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">final_ab</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">room</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">from_honeybee</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">room_2d</span></div>

<div class="viewcode-block" id="Room2D.from_polygon"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_polygon">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_polygon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                     <span class="n">boundary_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shading_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Room2D from a ladybug-geometry Polygon2D and a floor_height.</span>

<span class="sd">        Note that this method is not recommended for a Room with one or more holes</span>
<span class="sd">        (like a courtyard) since polygons cannot have holes within them.</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier: Text string for a unique Room2D ID. Must be &lt; 100 characters</span>
<span class="sd">                and not contain any spaces or special characters.</span>
<span class="sd">            polygon: A single Polygon2D object representing the floor plate of the Room.</span>
<span class="sd">            floor_height: A float value to place the polygon within 3D space.</span>
<span class="sd">            floor_to_ceiling_height: A number for the height above the floor where the</span>
<span class="sd">                ceiling begins. Typical values range from 3 to 5 meters.</span>
<span class="sd">            boundary_conditions: A list of boundary conditions that match the number of</span>
<span class="sd">                segments in the input floor_geometry. These will be used to assign</span>
<span class="sd">                boundary conditions to each of the walls of the Room in the resulting</span>
<span class="sd">                model. If None, all boundary conditions will be Outdoors or Ground</span>
<span class="sd">                depending on whether ceiling of the room is below 0 (the assumed</span>
<span class="sd">                ground plane). Default: None.</span>
<span class="sd">            window_parameters: A list of WindowParameter objects that dictate how the</span>
<span class="sd">                window geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no windows will exist over the entire Room2D. Default: None.</span>
<span class="sd">            shading_parameters: A list of ShadingParameter objects that dictate how the</span>
<span class="sd">                shade geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no shades will exist over the entire Room2D. Default: None.</span>
<span class="sd">            is_ground_contact: A boolean to note whether this Room2D has its floor</span>
<span class="sd">                in contact with the ground. Default: False.</span>
<span class="sd">            is_top_exposed: A boolean to note whether this Room2D has its ceiling</span>
<span class="sd">                exposed to the outdoors. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the input polygon and ensure it&#39;s counter-clockwise</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">Polygon2D</span><span class="p">),</span> \
            <span class="s1">&#39;Expected ladybug_geometry Polygon2D. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">polygon</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_clockwise</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">boundary_conditions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">boundary_conditions</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">window_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_win_pars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">win_par</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">window_parameters</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                        <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="p">)</span>
                <span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>
            <span class="k">if</span> <span class="n">shading_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shading_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">shading_parameters</span><span class="p">))</span>

        <span class="c1"># build the Face3D without using right-hand rule to ensure alignment w/ bcs</span>
        <span class="n">base_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">))</span>
        <span class="n">vert3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">base_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">vert3d</span><span class="p">,</span> <span class="n">base_plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">floor_geometry</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                   <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">window_parameters</span><span class="p">,</span> <span class="n">shading_parameters</span><span class="p">,</span>
                   <span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.from_vertices"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_vertices">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_vertices</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                      <span class="n">boundary_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">shading_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Room2D from 2D vertices with each vertex as an iterable of 2 floats.</span>

<span class="sd">        Note that this method is not recommended for a Room with one or more holes</span>
<span class="sd">        (like a courtyard) since the distinction between hole vertices and boundary</span>
<span class="sd">        vertices cannot be derived from a single list of vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier: Text string for a unique Room2D ID. Must be &lt; 100 characters</span>
<span class="sd">                and not contain any spaces or special characters.</span>
<span class="sd">            vertices: A flattened list of 2 or more vertices as (x, y) that trace</span>
<span class="sd">                the outline of the floor plate.</span>
<span class="sd">            floor_height: A float value to place the polygon within 3D space.</span>
<span class="sd">            floor_to_ceiling_height: A number for the height above the floor where the</span>
<span class="sd">                ceiling begins. Typical values range from 3 to 5 meters.</span>
<span class="sd">            boundary_conditions: A list of boundary conditions that match the number of</span>
<span class="sd">                segments in the input floor_geometry. These will be used to assign</span>
<span class="sd">                boundary conditions to each of the walls of the Room in the resulting</span>
<span class="sd">                model. If None, all boundary conditions will be Outdoors or Ground</span>
<span class="sd">                depending on whether ceiling of the room is below 0 (the assumed</span>
<span class="sd">                ground plane). Default: None.</span>
<span class="sd">            window_parameters: A list of WindowParameter objects that dictate how the</span>
<span class="sd">                window geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no windows will exist over the entire Room2D. Default: None.</span>
<span class="sd">            shading_parameters: A list of ShadingParameter objects that dictate how the</span>
<span class="sd">                shade geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no shades will exist over the entire Room2D. Default: None.</span>
<span class="sd">            is_ground_contact: A boolean to note whether this Room2D has its floor</span>
<span class="sd">                in contact with the ground. Default: False.</span>
<span class="sd">            is_top_exposed: A boolean to note whether this Room2D has its ceiling</span>
<span class="sd">                exposed to the outdoors. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_polygon</span><span class="p">(</span>
            <span class="n">identifier</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
            <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">window_parameters</span><span class="p">,</span> <span class="n">shading_parameters</span><span class="p">,</span>
            <span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">floor_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A horizontal Face3D object representing the floor plate of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">floor_to_ceiling_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a number for the distance between the floor and the ceiling.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span>

    <span class="nd">@floor_to_ceiling_height</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">floor_to_ceiling_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">float_positive</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;floor-to-ceiling height&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Room2D floor-to-ceiling height &#39;</span> \
            <span class="s1">&#39;cannot be zero.&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of boundary conditions for the wall boundary conditions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">)</span>

    <span class="nd">@boundary_conditions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">boundary_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;boundary conditions&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">,</span> <span class="s1">&#39;Expected BoundaryCondition. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)),</span> \
                    <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> cannot be assigned to a wall with windows.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">window_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of WindowParameters describing how to generate windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)</span>

    <span class="nd">@window_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">window_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;window_parameters&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_WindowParameterBase</span><span class="p">),</span> \
                        <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)),</span> \
                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> cannot be assigned to a wall with windows.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shading_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of ShadingParameters describing how to generate shades.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>

    <span class="nd">@shading_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shading_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;shading_parameters&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_ShadingParameterBase</span><span class="p">),</span> \
                        <span class="s1">&#39;Expected Shading Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">air_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of booleans for whether each wall has an air boundary type.</span>

<span class="sd">        False values indicate a standard opaque type while True values indicate</span>
<span class="sd">        an AirBoundary type. All walls will be False by default. Note that any</span>
<span class="sd">        walls with a True air boundary must have a Surface boundary condition</span>
<span class="sd">        without any windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">)</span>

    <span class="nd">@air_boundaries</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">air_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;air boundaries&#39;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="n">all_props</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">bnd</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="n">all_props</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bnd</span><span class="p">,</span> <span class="n">Surface</span><span class="p">),</span> <span class="s1">&#39;Air boundaries must be assigned &#39;</span> \
                        <span class="s1">&#39;to walls with Surface boundary conditions. Not </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bnd</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">glz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
                        <span class="s1">&#39;Air boundaries cannot be assigned to a wall with windows.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ground_contact</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a boolean noting whether the floor is in contact with the ground.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span>

    <span class="nd">@is_ground_contact</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_ground_contact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_top_exposed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a boolean noting whether the ceiling is exposed to the outdoors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span>

    <span class="nd">@is_top_exposed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_top_exposed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skylight_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set SkylightParameters describing how to generate skylights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>

    <span class="nd">@skylight_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">skylight_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_SkylightParameterBase</span><span class="p">),</span> \
                <span class="s1">&#39;Expected Skylight Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the parent Story if it is assigned. None if it is not assigned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a boolean noting whether this Room2D has a parent Story.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">floor_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of LineSegment3D objects for each wall of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> \
            <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">floor_segments_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of LineSegment2D objects for each wall of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span> <span class="k">if</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span>
                  <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segment_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of segments making up the floor geometry.</span>

<span class="sd">        This is equal to the number of walls making up the Room.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segment_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of Vector2D objects for the normal of each segment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Vector2D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">floor_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the height of the floor above the ground.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ceiling_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the height of the ceiling above the ground.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the volume of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_area</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">floor_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the floor area of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">area</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exterior_wall_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a the total wall area of the Room with an Outdoors boundary condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wall_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">):</span>
                <span class="n">wall_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wall_areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exterior_aperture_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a the total aperture area of the Room with an Outdoors boundary condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glz_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="ow">and</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                <span class="n">glz_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">glz_areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a boolean for whether the Room2D is in the core of a story.</span>

<span class="sd">        Core Room2Ds have no walls exposed to the outdoors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exterior_wall_area</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a boolean for whether the Room2D is on the perimeter of a story.</span>

<span class="sd">        Perimeter Room2Ds have walls exposed to the outdoors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exterior_wall_area</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point2D for the min bounding rectangle vertex in the XY plane.</span>

<span class="sd">        This is useful in calculations to determine if this Room2D is in proximity</span>
<span class="sd">        to other Room2Ds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">min</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point2D for the max bounding rectangle vertex in the XY plane.</span>

<span class="sd">        This is useful in calculations to determine if this Room2D is in proximity</span>
<span class="sd">        to other Room2Ds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">max</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point2D for the center bounding rectangle vertex in the XY plane.</span>

<span class="sd">        This is useful in calculations to determine if this Room2D is inside</span>
<span class="sd">        other polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">center</span>

<div class="viewcode-block" id="Room2D.segment_orientations"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_orientations">[docs]</a>    <span class="k">def</span> <span class="nf">segment_orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north_vector</span><span class="o">=</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A list of numbers between 0 and 360 for the orientation of the segments.</span>

<span class="sd">        0 = North, 90 = East, 180 = South, 270 = West</span>

<span class="sd">        Args:</span>
<span class="sd">            north_vector: A ladybug_geometry Vector2D for the north direction.</span>
<span class="sd">                Default is the Y-axis (0, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector2D</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">sg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">north_vector</span><span class="o">.</span><span class="n">angle_clockwise</span><span class="p">(</span><span class="n">norm</span><span class="p">))</span> <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="n">normals</span><span class="p">]</span></div>

<div class="viewcode-block" id="Room2D.set_outdoor_window_parameters"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_outdoor_window_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">set_outdoor_window_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_parameter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all of the outdoor walls to have the same window parameters.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">,</span> <span class="n">_WindowParameterBase</span><span class="p">),</span> \
            <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">))</span>
        <span class="n">glz_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="n">glz_p</span> <span class="o">=</span> <span class="n">window_parameter</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">glz_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">glz_ps</span></div>

<div class="viewcode-block" id="Room2D.set_outdoor_shading_parameters"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_outdoor_shading_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">set_outdoor_shading_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shading_parameter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all of the outdoor walls to have the same shading parameters.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shading_parameter</span><span class="p">,</span> <span class="n">_ShadingParameterBase</span><span class="p">),</span> \
            <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shading_parameter</span><span class="p">))</span>
        <span class="n">shd_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="n">shd_p</span> <span class="o">=</span> <span class="n">shading_parameter</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">shd_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">shd_ps</span></div>

<div class="viewcode-block" id="Room2D.to_rectangular_windows"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_rectangular_windows">[docs]</a>    <span class="k">def</span> <span class="nf">to_rectangular_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert all of the windows of the Room2D to the RectangularWindows format.&quot;&quot;&quot;</span>
        <span class="n">glz_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="n">glz_p</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">glz_p</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">to_rectangular_windows</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
            <span class="n">glz_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">glz_ps</span></div>

<div class="viewcode-block" id="Room2D.add_prefix"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.add_prefix">[docs]</a>    <span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the identifier of this object by inserting a prefix.</span>

<span class="sd">        This is particularly useful in workflows where you duplicate and edit</span>
<span class="sd">        a starting object and then want to combine it with the original object</span>
<span class="sd">        into one Model (like making a model of repeated rooms) since all objects</span>
<span class="sd">        within a Model must have unique identifiers.</span>

<span class="sd">        Args:</span>
<span class="sd">            prefix: Text that will be inserted at the start of this object&#39;s</span>
<span class="sd">                (and child segments&#39;) identifier and display_name. It is recommended</span>
<span class="sd">                that this prefix be short to avoid maxing out the 100 allowable</span>
<span class="sd">                characters for dragonfly identifiers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identifier</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">new_face_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_room_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">Surface</span><span class="p">((</span><span class="n">new_face_id</span><span class="p">,</span> <span class="n">new_room_id</span><span class="p">))</span></div>

<div class="viewcode-block" id="Room2D.generate_grid"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.generate_grid">[docs]</a>    <span class="k">def</span> <span class="nf">generate_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a gridded Mesh3D object offset from the floor of this room.</span>

<span class="sd">        Note that the x_dim and y_dim refer to dimensions within the XY coordinate</span>
<span class="sd">        system of the floor Faces&#39;s plane. So rotating the planes of the floor geometry</span>
<span class="sd">        will result in rotated grid cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_dim: The x dimension of the grid cells as a number.</span>
<span class="sd">            y_dim: The y dimension of the grid cells as a number. Default is None,</span>
<span class="sd">                which will assume the same cell dimension for y as is set for x.</span>
<span class="sd">            offset: A number for how far to offset the grid from the base face.</span>
<span class="sd">                Default is 1.0, which will not offset the grid to be 1 unit above</span>
<span class="sd">                the floor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">mesh_grid</span><span class="p">(</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.set_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_adjacency">[docs]</a>    <span class="k">def</span> <span class="nf">set_adjacency</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other_room_2d</span><span class="p">,</span> <span class="n">self_seg_index</span><span class="p">,</span> <span class="n">other_seg_index</span><span class="p">,</span>
            <span class="n">resolve_window_conflicts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a segment of this Room2D to be adjacent to another and vice versa.</span>

<span class="sd">        Note that, adjacent segments must possess matching WindowParameters in</span>
<span class="sd">        order to be valid.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_room_2d: Another Room2D object to be set adjacent to this one.</span>
<span class="sd">            self_seg_index: An integer for the wall segment of this Room2D that</span>
<span class="sd">                will be set adjacent to the other_room_2d.</span>
<span class="sd">            other_seg_index:An integer for the wall segment of the other_room_2d</span>
<span class="sd">                that will be set adjacent to this Room2D.</span>
<span class="sd">            resolve_window_conflicts: Boolean to note whether conflicts between</span>
<span class="sd">                window parameters of adjacent segments should be resolved during</span>
<span class="sd">                adjacency setting or an error should be raised about the mismatch.</span>
<span class="sd">                Resolving conflicts will default to the window parameters with the</span>
<span class="sd">                larger are and assign them to the other segment. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_room_2d</span><span class="p">,</span> <span class="n">Room2D</span><span class="p">),</span> \
            <span class="s1">&#39;Expected dragonfly Room2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other_room_2d</span><span class="p">))</span>
        <span class="c1"># set the boundary conditions of the segments</span>
        <span class="n">ids_1</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">..Face</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">self_seg_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
        <span class="n">ids_2</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">..Face</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other_room_2d</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">other_seg_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">other_room_2d</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">ids_2</span><span class="p">)</span>
        <span class="n">other_room_2d</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">ids_1</span><span class="p">)</span>
        <span class="c1"># check that the window parameters match between segments</span>
        <span class="n">wp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span>
        <span class="n">wp2</span> <span class="o">=</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wp1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">wp2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wp1</span> <span class="o">!=</span> <span class="n">wp2</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp1</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">resolve_window_conflicts</span><span class="p">:</span>
                    <span class="n">ftc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
                    <span class="n">ftc2</span> <span class="o">=</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
                    <span class="n">min_ftc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">ftc1</span><span class="p">,</span> <span class="n">ftc2</span><span class="p">))</span>
                    <span class="n">seg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span>
                    <span class="n">a1</span> <span class="o">=</span> <span class="n">wp1</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">min_ftc</span><span class="p">)</span> <span class="k">if</span> <span class="n">wp1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">seg2</span> <span class="o">=</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span>
                    <span class="n">a2</span> <span class="o">=</span> <span class="n">wp2</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg2</span><span class="p">,</span> <span class="n">min_ftc</span><span class="p">)</span> <span class="k">if</span> <span class="n">wp2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">a1</span> <span class="o">&gt;</span> <span class="n">a2</span><span class="p">:</span>
                        <span class="n">other_room_2d</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">wp1</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp1</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">)</span> \
                            <span class="k">else</span> <span class="n">wp1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">wp2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp2</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">wp2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wp1</span> <span class="o">!=</span> <span class="n">wp2</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Window parameters do not match between adjacent &#39;</span> \
                            <span class="s1">&#39;Rooms &quot;</span><span class="si">{}</span><span class="s1">&quot; and &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.set_boundary_condition"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_boundary_condition">[docs]</a>    <span class="k">def</span> <span class="nf">set_boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_index</span><span class="p">,</span> <span class="n">boundary_condition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single segment of this Room2D to have a certain boundary condition.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_index: An integer for the wall segment of this Room2D for which</span>
<span class="sd">                the boundary condition will be set.</span>
<span class="sd">            boundary_condition: A boundary condition object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">boundary_condition</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">,</span> \
            <span class="s1">&#39;Expected boundary condition. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">boundary_condition</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)),</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> cannot be &#39;</span> \
                <span class="s1">&#39;assigned to a wall with windows.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">boundary_condition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_condition</span></div>

<div class="viewcode-block" id="Room2D.set_air_boundary"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_air_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">set_air_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single segment of this Room2D to have an air boundary type.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_index: An integer for the wall segment of this Room2D for which</span>
<span class="sd">                the boundary condition will be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>  <span class="c1"># trigger generation of values if they don&#39;t exist</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s1">&#39;Air boundaries cannot be assigned to a wall with windows.&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">],</span> <span class="n">Surface</span><span class="p">),</span> \
            <span class="s1">&#39;Air boundaries must be assigned to walls with Surface boundary conditions.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Room2D.set_window_parameter"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_window_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">set_window_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_index</span><span class="p">,</span> <span class="n">window_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single segment of this Room2D to have a certain window parameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_index: An integer for the wall segment of this Room2D for which</span>
<span class="sd">                the window parameter will be set.</span>
<span class="sd">            window_parameter: A window parameter object to be assigned to the segment.</span>
<span class="sd">                If None, any existing WindowParameters assigned to the segment</span>
<span class="sd">                will be removed. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">window_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">,</span> <span class="n">_WindowParameterBase</span><span class="p">),</span> \
                <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">))</span>
            <span class="n">accept_bc</span> <span class="o">=</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">],</span> <span class="n">accept_bc</span><span class="p">),</span> \
                <span class="s1">&#39;Windows cannot be assigned to a wall with </span><span class="si">{}</span><span class="s1"> boundary &#39;</span> \
                <span class="s1">&#39;condition.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">window_parameter</span></div>

<div class="viewcode-block" id="Room2D.reset_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.reset_adjacency">[docs]</a>    <span class="k">def</span> <span class="nf">reset_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all Surface boundary conditions of this Room2D to be Outdoors.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span></div>

<div class="viewcode-block" id="Room2D.move"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_vec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move this Room2D along a vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            moving_vec: A ladybug_geometry Vector3D with the direction and distance</span>
<span class="sd">                to move the room.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.rotate_xy"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.rotate_xy">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate this Room2D counterclockwise in the XY plane by a certain angle.</span>

<span class="sd">        Args:</span>
<span class="sd">            angle: An angle in degrees.</span>
<span class="sd">            origin: A ladybug_geometry Point3D for the origin around which the</span>
<span class="sd">                object will be rotated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">origin</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.reflect"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.reflect">[docs]</a>    <span class="k">def</span> <span class="nf">reflect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reflect this Room2D across a plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            plane: A ladybug_geometry Plane across which the object will be reflected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="s1">&#39;Plane normal must be in XY plane to use it on Room2D.reflect.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win_pars</span><span class="p">,</span> <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_flip_wall_assigned_objects</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd_pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.scale"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale this Room2D by a factor from an origin point.</span>

<span class="sd">        Note that this will scale both the Room2D geometry and the WindowParameters</span>
<span class="sd">        and FacadeParameters assigned to this Room2D.</span>

<span class="sd">        Args:</span>
<span class="sd">            factor: A number representing how much the object should be scaled.</span>
<span class="sd">            origin: A ladybug_geometry Point3D representing the origin from which</span>
<span class="sd">                to scale. If None, it will be scaled from the World origin (0, 0, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># scale the Room2D geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">*</span> <span class="n">factor</span>

        <span class="c1"># scale the window parameters</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">win_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">win_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_par</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># scale the shading parameters</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shd_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shd_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shd_par</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># scale the skylight parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> \
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">)</span> <span class="k">else</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.align"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.align">[docs]</a>    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_ray</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move any Room2D vertices within a given distance of a line to be on that line.</span>

<span class="sd">        This is useful to clean up cases where wall segments have a lot of</span>
<span class="sd">        zig zags in them.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved and the number of</span>
<span class="sd">        vertices will remain constant. This means that this method can often create</span>
<span class="sd">        duplicate vertices and it might be desirable to run the remove_duplicate_vertices</span>
<span class="sd">        method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_ray: A ladybug_geometry Ray2D or LineSegment2D to which the Room2D</span>
<span class="sd">                vertices will be aligned. Ray2Ds will be interpreted as being infinite</span>
<span class="sd">                in both directions while LineSegment2Ds will be interpreted as only</span>
<span class="sd">                existing between two points.</span>
<span class="sd">            distance: The maximum distance between a vertex and the line_ray where</span>
<span class="sd">                the vertex will be moved to lie on the line_ray. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the line_ray for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_ray</span><span class="p">,</span> <span class="n">Ray2D</span><span class="p">):</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">Ray3D</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">closest_func</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d_infinite</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_ray</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">closest_func</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected Ray2D or LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line_ray</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># loop through the vertices and align them</span>
        <span class="n">new_boundary</span><span class="p">,</span> <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">:</span>
            <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_func</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_func</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="n">new_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.remove_duplicate_vertices"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_duplicate_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">remove_duplicate_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove duplicate vertices from this Room2D.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the line it lies</span>
<span class="sd">                upon at which point the vertex is considered colinear. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of integers for the indices of segments that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop through the vertices and remove any duplicates</span>
        <span class="n">exist_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
        <span class="n">new_bound</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">b_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">b_pts</span> <span class="o">=</span> <span class="n">b_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
        <span class="n">removed_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b_pts</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vert</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">b_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="n">new_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">removed_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">new_holes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">new_holes</span><span class="p">,</span> <span class="n">seg_count</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_pts</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">new_h_pts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">h_pts</span> <span class="o">=</span> <span class="n">hole</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">h_pts</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vert</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">h_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="n">new_h_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                        <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                        <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">removed_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_h_pts</span><span class="p">)</span>
                <span class="n">seg_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_pts</span><span class="p">)</span>

        <span class="c1"># assign the geometry and properties</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
                <span class="n">new_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># usually a sliver face of some kind</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; is degenerate with dimensions less than the &#39;</span>
                <span class="s1">&#39;tolerance.</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
        <span class="k">return</span> <span class="n">removed_indices</span></div>

<div class="viewcode-block" id="Room2D.remove_colinear_vertices"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_colinear_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">remove_colinear_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">preserve_wall_props</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a version of this Room2D without colinear or duplicate vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the line it lies</span>
<span class="sd">                upon at which point the vertex is considered colinear. Default: 0.01,</span>
<span class="sd">                suitable for objects in meters.</span>
<span class="sd">            preserve_wall_props: Boolean to note whether existing window parameters</span>
<span class="sd">                and Ground boundary conditions should be preserved as vertices are</span>
<span class="sd">                removed. If False, all boundary conditions are replaced with Outdoors,</span>
<span class="sd">                all window parameters are erased, and this method will execute quickly.</span>
<span class="sd">                If True, an attempt will be made to merge window parameters together</span>
<span class="sd">                across colinear segments, translating simple window parameters to</span>
<span class="sd">                rectangular ones if necessary. Also, existing Ground boundary</span>
<span class="sd">                conditions will be kept. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_wall_props</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># remove colinear vertices from the Room2D</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># usually a sliver face of some kind</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; is degenerate with dimensions less than the &#39;</span>
                    <span class="s1">&#39;tolerance.</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ftc_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>  <span class="c1"># only need to evaluate one list</span>
                <span class="n">pts_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">pts_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">polygon2d</span>
                <span class="n">segs_2d</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="o">.</span><span class="n">segments</span>
                <span class="n">bound_cds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span>
                <span class="n">win_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span>
                <span class="n">bound_verts</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear_props</span><span class="p">(</span>
                    <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pts_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
                <span class="n">pts_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
                <span class="n">segs_2d</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="o">.</span><span class="n">segments</span>
                <span class="n">st_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)</span>
                <span class="n">bound_cds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">[:</span><span class="n">st_i</span><span class="p">]</span>
                <span class="n">win_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">[:</span><span class="n">st_i</span><span class="p">]</span>
                <span class="n">bound_verts</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear_props</span><span class="p">(</span>
                    <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pts_3d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
                    <span class="n">pts_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">segs_2d</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="o">.</span><span class="n">segments</span>
                    <span class="n">bound_cds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">[</span><span class="n">st_i</span><span class="p">:</span><span class="n">st_i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)]</span>
                    <span class="n">win_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">[</span><span class="n">st_i</span><span class="p">:</span><span class="n">st_i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)]</span>
                    <span class="n">st_i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)</span>
                    <span class="n">h_verts</span><span class="p">,</span> <span class="n">h_bcs</span><span class="p">,</span> <span class="n">h_w_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear_props</span><span class="p">(</span>
                        <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span>
                        <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_verts</span><span class="p">)</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">h_bcs</span><span class="p">)</span>
                    <span class="n">new_w_par</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">h_w_par</span><span class="p">)</span>

            <span class="c1"># create the new Room2D</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">holes</span><span class="p">)</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">new_bcs</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="n">new_w_par</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>

        <span class="c1"># assign overall properties to the rebuilt room</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rebuilt_room</span></div>

<div class="viewcode-block" id="Room2D.remove_short_segments"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_short_segments">[docs]</a>    <span class="k">def</span> <span class="nf">remove_short_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a version of this Room2D with consecutive short segments removed.</span>

<span class="sd">        To patch over the segments, an attempt will first be made to find the</span>
<span class="sd">        intersection of the two neighboring segments. If these two lines are parallel,</span>
<span class="sd">        they will simply be connected with a segment.</span>

<span class="sd">        Properties assigned to the Room2D will be preserved for the segments that</span>
<span class="sd">        are not removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            distance: The maximum length of a segment below which the segment</span>
<span class="sd">                will be considered for removal.</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that vertices</span>
<span class="sd">                are allowed to differ from one another in order to consider them</span>
<span class="sd">                colinear. (Default: 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check if there are contiguous short segments to be removed</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span><span class="p">:</span>
                <span class="n">segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="n">sh_seg_i</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">]</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh_seg_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># large distance means the whole Face becomes removed</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sh_seg_i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># no short segments to remove</span>
        <span class="n">del_seg_i</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sh_seg</span> <span class="ow">in</span> <span class="n">sh_seg_i</span><span class="p">:</span>
            <span class="n">del_seg</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">):</span>
                <span class="n">test_val</span> <span class="o">=</span> <span class="n">seg_i</span> <span class="o">-</span> <span class="n">sh_seg</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">test_val</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">seg_i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">test_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seg_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">sh_seg</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">sh_seg</span><span class="p">:</span>
                <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">del_seg_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">del_seg</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">del_seg_i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># there are short segments but they&#39;re not contiguous</span>

        <span class="c1"># contiguous short segments found</span>
        <span class="c1"># collect the vertices and indices of properties to be removed</span>
        <span class="n">a_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">prev_i</span><span class="p">,</span> <span class="n">final_pts</span><span class="p">,</span> <span class="n">del_prop_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p_segs</span><span class="p">,</span> <span class="n">del_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">del_seg_i</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">del_i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># set up variables to handle getting the last vertex to connect to</span>
                <span class="n">new_points</span><span class="p">,</span> <span class="n">in_del</span><span class="p">,</span> <span class="n">post_del</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">del_i</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">del_i</span><span class="p">:</span>
                    <span class="n">last_i</span><span class="p">,</span> <span class="n">in_del</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">while</span> <span class="n">del_i</span><span class="p">[</span><span class="n">last_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">del_i</span><span class="p">[</span><span class="n">last_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">last_i</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># entire hole to be removed</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)):</span>
                            <span class="n">del_prop_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_i</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">p_segs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># loop through the segments and delete the short ones</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_segs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">del_i</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_del</span><span class="p">:</span>
                            <span class="n">last_i</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">in_del</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">del_prop_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_i</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">rel_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">rel_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">del_i</span><span class="p">:</span>  <span class="c1"># we are at the end of the deletion</span>
                            <span class="c1"># see if we can repair the hole by extending segments</span>
                            <span class="n">l3a</span><span class="p">,</span> <span class="n">l3b</span> <span class="o">=</span> <span class="n">p_segs</span><span class="p">[</span><span class="n">last_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p_segs</span><span class="p">[</span><span class="n">rel_i</span><span class="p">]</span>
                            <span class="n">l2a</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">l3a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                        <span class="n">Vector2D</span><span class="p">(</span><span class="n">l3a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                            <span class="n">l2b</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">l3b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                        <span class="n">Vector2D</span><span class="p">(</span><span class="n">l3b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                            <span class="n">v_ang</span> <span class="o">=</span> <span class="n">l2a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">l2b</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">v_ang</span> <span class="o">&lt;=</span> <span class="n">a_tol</span> <span class="ow">or</span> <span class="n">v_ang</span> <span class="o">&gt;=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">a_tol</span><span class="p">:</span>  <span class="c1"># parallel</span>
                                <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_segs</span><span class="p">[</span><span class="n">last_i</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                                <span class="n">del_prop_i</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># put back the last property</span>
                            <span class="k">else</span><span class="p">:</span>  <span class="c1"># extend lines to the intersection</span>
                                <span class="n">int_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersect_line2d_infinite</span><span class="p">(</span><span class="n">l2a</span><span class="p">,</span> <span class="n">l2b</span><span class="p">)</span>
                                <span class="n">int_pt3</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">int_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
                                <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_pt3</span><span class="p">)</span>
                                <span class="n">post_del</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">in_del</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">post_del</span><span class="p">:</span>
                            <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lin</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">post_del</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">post_del</span><span class="p">:</span>
                    <span class="n">new_points</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># put back the last property</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">final_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no short segments to remove on this hole or boundary</span>
                <span class="n">final_pts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lin</span><span class="o">.</span><span class="n">p</span> <span class="k">for</span> <span class="n">lin</span> <span class="ow">in</span> <span class="n">p_segs</span><span class="p">])</span>
            <span class="n">prev_i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)</span>

        <span class="c1"># create the geometry and convert properties for the new segments</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">final_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">final_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">holes</span><span class="p">)</span>
        <span class="n">new_bcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[:]</span>
        <span class="n">new_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[:]</span>
        <span class="n">new_shd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[:]</span>
        <span class="n">new_abs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span><span class="p">)</span>
        <span class="n">all_props</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prop_list</span> <span class="ow">in</span> <span class="n">all_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">del_prop_i</span><span class="p">):</span>
                <span class="n">prop_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">di</span><span class="p">)</span>

        <span class="c1"># create the final rebuilt Room2D and return it</span>
        <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span>
            <span class="n">new_shd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rebuilt_room</span></div>

<div class="viewcode-block" id="Room2D.remove_degenerate_holes"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_degenerate_holes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_degenerate_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any holes in this Room2D with an area that evaluates to zero.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="c1"># first identify any zero-area holes</span>
            <span class="n">holes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
                <span class="n">test_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">test_face</span><span class="o">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">holes_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># if zero-area holes were found, rebuild the Room2D</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">holes_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># first collect the properties of the boundary</span>
                <span class="n">exist_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
                <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">seg_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seg_count</span><span class="p">):</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># collect the properties of the new holes</span>
                <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">hi</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">hi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">holes_to_remove</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hole</span><span class="p">):</span>
                            <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                            <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                            <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                            <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
                    <span class="n">seg_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
                <span class="c1"># reset the properties of the Room2D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span></div>

<div class="viewcode-block" id="Room2D.check_horizontal"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_horizontal">[docs]</a>    <span class="k">def</span> <span class="nf">check_horizontal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the Room2D&#39;s floor geometry is horizontal within a tolerance.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The maximum difference between z values at which</span>
<span class="sd">                face vertices are considered at different heights. Default: 0.01,</span>
<span class="sd">                suitable for objects in meters.</span>
<span class="sd">            raise_exception: Boolean to note whether a ValueError should be raised</span>
<span class="sd">                if the room floor geometry is not horizontal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Room &quot;</span><span class="si">{}</span><span class="s1">&quot; is not horizontal to within </span><span class="si">{}</span><span class="s1"> tolerance.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span></div>

<div class="viewcode-block" id="Room2D.check_window_parameters_valid"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_window_parameters_valid">[docs]</a>    <span class="k">def</span> <span class="nf">check_window_parameters_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detailed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the Room2D&#39;s window parameters produce valid apertures.</span>

<span class="sd">        This means that the resulting Apertures are completely bounded by their</span>
<span class="sd">        parent wall Face.</span>

<span class="sd">        Args:</span>
<span class="sd">            raise_exception: Boolean to note whether a ValueError should be raised</span>
<span class="sd">                if the window parameters are not valid.</span>
<span class="sd">            detailed: Boolean for whether the returned object is a detailed list of</span>
<span class="sd">                dicts with error info or a string with a message. (Default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string with the message or a list with a dictionary if detailed is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">detailed</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">raise_exception</span> <span class="k">else</span> <span class="n">detailed</span>
        <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">checkable_par</span> <span class="o">=</span> <span class="p">(</span><span class="n">RectangularWindows</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">wp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">checkable_par</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">check_valid_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">msg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Segment [</span><span class="si">{}</span><span class="s1">] - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">check_valid_for_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">msg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Skylights - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">detailed</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">full_msg</span> <span class="o">=</span> <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; contains invalid window parameters.&#39;</span> \
            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msgs</span><span class="p">))</span>
        <span class="n">full_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_message_child</span><span class="p">(</span>
            <span class="n">full_msg</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">detailed</span><span class="p">,</span> <span class="s1">&#39;100101&#39;</span><span class="p">,</span> <span class="n">error_type</span><span class="o">=</span><span class="s1">&#39;Invalid Window Parameters&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detailed</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">full_msg</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">full_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full_msg</span></div>

<div class="viewcode-block" id="Room2D.to_honeybee"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_honeybee">[docs]</a>    <span class="k">def</span> <span class="nf">to_honeybee</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">add_plenum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">enforce_bc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert Dragonfly Room2D to a Honeybee Room.</span>

<span class="sd">        Args:</span>
<span class="sd">            multiplier: An integer greater than 0 that denotes the number of times</span>
<span class="sd">                the room is repeated. You may want to set this differently depending</span>
<span class="sd">                on whether you are exporting each room as its own geometry (in which</span>
<span class="sd">                case, this should be 1) or you only want to simulate the &quot;unique&quot; room</span>
<span class="sd">                once and have the results multiplied. Default: 1.</span>
<span class="sd">            add_plenum: Boolean to indicate whether ceiling/floor plenums should</span>
<span class="sd">                be auto-generated for the Room in which case this output will</span>
<span class="sd">                be a list instead of a single Room. The height of the ceiling plenum</span>
<span class="sd">                will be autocalculated as the difference between the Room2D</span>
<span class="sd">                ceiling height and Story ceiling height. The height of the floor</span>
<span class="sd">                plenum will be autocalculated as the difference between the Room2D</span>
<span class="sd">                floor height and Story floor height. (Default: False).</span>
<span class="sd">            tolerance: The minimum distance in z values of floor_height and</span>
<span class="sd">                floor_to_ceiling_height at which adjacent Faces will be split.</span>
<span class="sd">                This is also used in the generation of Windows, and to check if the</span>
<span class="sd">                Room ceiling is adjacent to the upper floor of the Story before</span>
<span class="sd">                generating a plenum. Default: 0.01, suitable for objects in meters.</span>
<span class="sd">            enforce_bc: Boolean to note whether an exception should be raised if</span>
<span class="sd">                apertures are assigned to Wall with an illegal boundary conditions</span>
<span class="sd">                (True) or if the invalid boundary condition should be replaced</span>
<span class="sd">                with an Outdoor boundary condition (False). (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with the two items below.</span>

<span class="sd">            * hb_room -- If add_plenum is False, this will be honeybee-core Room</span>
<span class="sd">                representing the dragonfly Room2D. If the add_plenum argument is True,</span>
<span class="sd">                this item will be a list of honeybee-core Rooms, with the hb_room as</span>
<span class="sd">                the first item, and up to two additional items:</span>

<span class="sd">                * ceil_plenum -- A honeybee-core Room representing the ceiling</span>
<span class="sd">                    plenum. If there isn&#39;t enough space between the Story</span>
<span class="sd">                    floor_to_floor_height and the Room2D floor_to_ceiling height,</span>
<span class="sd">                    this item will be None.</span>

<span class="sd">                * floor_plenum -- A honeybee-core Room representing the floor plenum.</span>
<span class="sd">                    If there isn&#39;t enough space between the Story floor_height and</span>
<span class="sd">                    the Room2D floor_height, this item will be None.</span>

<span class="sd">            * adjacencies -- A list of tuples that record any adjacencies that</span>
<span class="sd">                should be set on the level of the Story to which the Room2D belongs.</span>
<span class="sd">                Each tuple will have a honeybee Face as the first item and a</span>
<span class="sd">                tuple of Surface.boundary_condition_objects as the second item.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the honeybee Room</span>
        <span class="n">has_roof</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_roof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># generate the room volume from the slanted roof</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="n">multiplier</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_room_volume_with_roof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_roof</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="n">has_roof</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">room_polyface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_roof</span><span class="p">:</span>  <span class="c1"># generate the Room volume normally</span>
            <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_offset_face</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
            <span class="n">roof_face_i</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create the honeybee Room and set the RoofCeiling faces</span>
        <span class="n">hb_room</span> <span class="o">=</span> <span class="n">Room</span><span class="o">.</span><span class="n">from_polyface3d</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">ground_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">roof_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">roof_face_i</span><span class="p">:</span>
            <span class="n">rfc</span> <span class="o">=</span> <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rfc</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ftyp</span><span class="o">.</span><span class="n">roof_ceiling</span>
            <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rfc</span><span class="p">)</span>

        <span class="c1"># assign BCs and record any Surface conditions to be set on the story level</span>
        <span class="n">adjacencies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_boundary_condition</span> <span class="o">=</span> <span class="n">bc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adjacencies</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">))</span>

        <span class="c1"># assign windows, shading, and air boundary properties to walls</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">glz_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">glz_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">enforce_bc</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                    <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove_sub_faces</span><span class="p">()</span>
                    <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shd_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shd_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shd_par</span><span class="o">.</span><span class="n">add_shading_to_face</span><span class="p">(</span><span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_bnd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a_bnd</span><span class="p">:</span>
                    <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ftyp</span><span class="o">.</span><span class="n">air_boundary</span>

        <span class="c1"># ensure matching adjacent Faces across the Story</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_roof</span><span class="p">:</span>
            <span class="n">new_faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_walls_along_height</span><span class="p">(</span><span class="n">hb_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">add_plenum</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_faces</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hb_room</span><span class="p">):</span>
                <span class="c1"># rebuild the room with split surfaces</span>
                <span class="n">hb_room</span> <span class="o">=</span> <span class="n">Room</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
                <span class="c1"># update adjacencies with the new split face</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adjacencies</span><span class="p">):</span>
                    <span class="n">face_id</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span>
                    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">face</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="n">face_id</span><span class="p">:</span>
                            <span class="n">adjacencies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">adj</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">break</span>

        <span class="c1"># set the story, multiplier, display_name, and user_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="o">.</span><span class="n">story</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">display_name</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">multiplier</span> <span class="o">=</span> <span class="n">multiplier</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>

        <span class="c1"># assign boundary conditions for the roof and floor</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
            <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                <span class="n">rf</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># honeybee_energy is not loaded and Adiabatic type doesn&#39;t exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                <span class="n">rf</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>

        <span class="c1"># transfer any extension properties assigned to the Room2D and return result</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">to_honeybee</span><span class="p">(</span><span class="n">hb_room</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">add_plenum</span> <span class="ow">or</span> <span class="n">has_roof</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">add_skylight_to_face</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hb_room</span><span class="p">,</span> <span class="n">adjacencies</span>

        <span class="c1"># add plenums if requested and return results</span>
        <span class="n">hb_plenums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_honeybee_plenums</span><span class="p">(</span><span class="n">hb_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hb_plenum</span> <span class="ow">in</span> <span class="n">hb_plenums</span><span class="p">:</span>  <span class="c1"># transfer the parent&#39;s construction set</span>
            <span class="n">hb_plenum</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">to_honeybee</span><span class="p">(</span><span class="n">hb_plenum</span><span class="p">)</span>
            <span class="n">hb_plenum</span><span class="o">.</span><span class="n">exclude_floor_area</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># set the program to unconditioned plenum and assign infiltration</span>
                <span class="n">hb_plenum</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">program_type</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">hb_plenum</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">hvac</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">hb_plenum</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">_shw</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">hb_plenum</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">infiltration</span> <span class="o">=</span> \
                    <span class="n">hb_room</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">infiltration</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># honeybee-energy is not loaded; ignore all these energy properties</span>

        <span class="c1"># set the skylights if top is exposed and there&#39;s no ceiling plenum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hb_plenums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">add_skylight_to_face</span><span class="p">(</span>
                        <span class="n">hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">hb_plenums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> \
                        <span class="n">hb_plenums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;floor_plenum&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">add_skylight_to_face</span><span class="p">(</span>
                        <span class="n">hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># return the rooms and the adjacency information</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">hb_room</span><span class="p">]</span> <span class="o">+</span> <span class="n">hb_plenums</span><span class="p">,</span> <span class="n">adjacencies</span></div>

<div class="viewcode-block" id="Room2D.to_dict"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abridged</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">included_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Room2D as a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            abridged: Boolean to note whether the extension properties of the</span>
<span class="sd">                object (ie. program_type, construction_set) should be included in detail</span>
<span class="sd">                (False) or just referenced by identifier (True). Default: False.</span>
<span class="sd">            included_prop: List of properties to filter keys that must be included in</span>
<span class="sd">                output dictionary. For example [&#39;energy&#39;] will include &#39;energy&#39; key if</span>
<span class="sd">                available in properties to_dict. By default all the keys will be</span>
<span class="sd">                included. To exclude all the keys from extensions use an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Room2D&#39;</span><span class="p">}</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;identifier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;display_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">abridged</span><span class="p">,</span> <span class="n">included_prop</span><span class="p">)</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_holes&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">[[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">]</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_to_ceiling_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;is_ground_contact&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;is_top_exposed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span>

        <span class="n">bc_dicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;energy&#39;</span> <span class="ow">in</span> <span class="n">base</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]:</span>
                <span class="n">bc_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bc_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;boundary_conditions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_dicts</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)):</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">glz</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">base</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)):</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">shd</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">shd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">base</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="ow">not</span> <span class="n">param</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">)):</span>
                <span class="n">base</span><span class="p">[</span><span class="s1">&#39;air_boundaries&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;user_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span>

        <span class="k">return</span> <span class="n">base</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Room2D writer object.</span>

<span class="sd">        Use this method to access Writer class to write the room2d in other formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">writer</span>

<div class="viewcode-block" id="Room2D.solve_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.solve_adjacency">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">solve_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">resolve_window_conflicts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve for all adjacencies between a list of input Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacencies will be solved.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            resolve_window_conflicts: Boolean to note whether conflicts between</span>
<span class="sd">                window parameters of adjacent segments should be resolved during</span>
<span class="sd">                adjacency setting or an error should be raised about the mismatch.</span>
<span class="sd">                Resolving conflicts will default to the window parameters with the</span>
<span class="sd">                larger are and assign them to the other segment. (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples with each tuple containing 2 sub-tuples for wall</span>
<span class="sd">            segments paired in the process of solving adjacency. Sub-tuples have</span>
<span class="sd">            the Room2D as the first item and the index of the adjacent wall as the</span>
<span class="sd">            second item. This data can be used to assign custom properties to the</span>
<span class="sd">            new adjacent walls (like assigning custom window parameters for</span>
<span class="sd">            interior windows, assigning air boundaries, or custom boundary</span>
<span class="sd">            conditions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rwc</span> <span class="o">=</span> <span class="n">resolve_window_conflicts</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                            <span class="n">room_1</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span>
                            <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; adjacency impossible</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">seg_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_1</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">Surface</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                                        <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                    <span class="c1"># set the boundary conditions of the segments</span>
                                    <span class="n">room_1</span><span class="o">.</span><span class="n">set_adjacency</span><span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">rwc</span><span class="p">)</span>
                                    <span class="n">adj_info</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">room_1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># we have reached the end of the list of rooms</span>
        <span class="k">return</span> <span class="n">adj_info</span></div>

<div class="viewcode-block" id="Room2D.find_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list with all adjacent pairs of segments between input Room2Ds.</span>

<span class="sd">        Note that this method does not change any boundary conditions of the input</span>
<span class="sd">        Room2Ds or mutate them in any way. It&#39;s purely a geometric analysis of the</span>
<span class="sd">        segments between Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacencies will be solved.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples for each discovered adjacency. Each tuple contains</span>
<span class="sd">            2 sub-tuples with two elements. The first element is the Room2D and</span>
<span class="sd">            the second is the index of the wall segment that is adjacent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># lists of adjacencies to track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                            <span class="n">room_1</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span>
                            <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; adjacency impossible</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">seg_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_1</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                                    <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                <span class="n">adj_info</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">room_1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># we have reached the end of the list of rooms</span>
        <span class="k">return</span> <span class="n">adj_info</span></div>

<div class="viewcode-block" id="Room2D.intersect_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.intersect_adjacency">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">intersect_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">preserve_wall_props</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersect the line segments of an array of Room2Ds to ensure matching walls.</span>

<span class="sd">        Also note that this method does not actually set the walls that are next to one</span>
<span class="sd">        another to be adjacent. The solve_adjacency method must be used for this after</span>
<span class="sd">        running this method.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacent segments will be</span>
<span class="sd">                intersected.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. Default: 0.01,</span>
<span class="sd">                suitable for objects in meters.</span>
<span class="sd">            preserve_wall_props: Boolean to note whether existing window parameters,</span>
<span class="sd">                shading parameters and boundary conditions should be preserved as</span>
<span class="sd">                vertices are added during intersection. If False, all boundary</span>
<span class="sd">                conditions are replaced with Outdoors, all window parameters are</span>
<span class="sd">                erased, and this method will execute quickly. If True, an attempt</span>
<span class="sd">                will be made to split window parameters new across colinear segments.</span>
<span class="sd">                Existing boundary conditions will also be kept. (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            An array of Room2Ds that have been intersected with one another.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep track of all data needed to map between 2D and 3D space</span>
        <span class="n">master_plane</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span>
        <span class="n">move_dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_holes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">polygon_2ds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>

        <span class="c1"># map all Room geometry into the same 2D space</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="c1"># ensure all starting room heights match</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">master_plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_height</span>
            <span class="n">move_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># record all distances moved</span>
            <span class="n">is_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># record that first Polygon doesn&#39;t have holes</span>
            <span class="n">polygon_2ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">)</span>
            <span class="c1"># of there are holes in the face, add them as their own polygons</span>
            <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">:</span>
                    <span class="n">move_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># record all distances moved</span>
                    <span class="n">is_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># record that first Polygon doesn&#39;t have holes</span>
                    <span class="n">polygon_2ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>

        <span class="c1"># intersect the Room2D polygons within the 2D space</span>
        <span class="n">int_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">intersect_polygon_segments</span><span class="p">(</span><span class="n">polygon_2ds</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># convert the resulting coordinates back to 3D space</span>
        <span class="n">face_pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">is_hole</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">int_poly</span><span class="p">,</span> <span class="n">move_dists</span><span class="p">,</span> <span class="n">is_holes</span><span class="p">):</span>
            <span class="n">pt_3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">master_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pt_3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pt_3d</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hole</span><span class="p">:</span>
                <span class="n">face_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pt_3d</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">face_pts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span>

        <span class="c1"># rebuild all of the floor geometries to the input Room2Ds</span>
        <span class="n">intersected_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">face_loops</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">face_pts</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no holes</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">face_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># ensure holes are included</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">face_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span>
                                 <span class="n">face_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">skylight_parameters</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">display_name</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_parent</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
            <span class="n">intersected_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rebuilt_room</span><span class="p">)</span>

        <span class="c1"># transfer the wall properties if requested</span>
        <span class="k">if</span> <span class="n">preserve_wall_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">orig_r</span><span class="p">,</span> <span class="n">new_r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">intersected_rooms</span><span class="p">):</span>
                <span class="c1"># get the relevant original segments to check for matches</span>
                <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">o_zip_props</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orig_r</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="n">orig_r</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span>
                                  <span class="n">orig_r</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="n">orig_r</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">shd</span> <span class="ow">in</span> <span class="n">o_zip_props</span><span class="p">:</span>
                    <span class="n">rel_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                    <span class="n">rel_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
                    <span class="n">rel_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                        <span class="n">rel_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rel_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                <span class="c1"># build up new lists of parameters if the segments match</span>
                <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rel_segs</span><span class="p">):</span>
                    <span class="n">m_win_segs</span><span class="p">,</span> <span class="n">m_i</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_r</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="ow">and</span> \
                                <span class="n">seg1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># colinear</span>
                            <span class="n">new_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_bcs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="n">new_shd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_shd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="n">m_win_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg2</span><span class="p">)</span>
                            <span class="n">m_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="c1"># split the window parameters across the matched segments</span>
                    <span class="n">wp_par_to_split</span> <span class="o">=</span> <span class="n">rel_win</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">wp_par_to_split</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m_i</span><span class="p">:</span>
                            <span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">new_win</span><span class="p">[</span><span class="n">m_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">wp_par_to_split</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">split_par</span> <span class="o">=</span> <span class="n">wp_par_to_split</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">m_win_segs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w_par</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">m_i</span><span class="p">,</span> <span class="n">split_par</span><span class="p">):</span>
                            <span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_par</span>

                <span class="n">new_r</span><span class="o">.</span><span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_r</span><span class="p">))]</span>
                <span class="n">new_r</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_r</span><span class="p">))]</span>
                <span class="n">new_r</span><span class="o">.</span><span class="n">shading_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_shd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_r</span><span class="p">))]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">intersected_rooms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.group_by_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_adjacency">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">group_by_adjacency</span><span class="p">(</span><span class="n">rooms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together that are connected by adjacencies.</span>

<span class="sd">        This is useful for separating rooms in the case where a Story contains</span>
<span class="sd">        multiple towers or sections that are separated by outdoor boundary conditions.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their adjacency.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of list with each sub-list containing rooms that share adjacencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_adjacency_grouping</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_find_adjacent_rooms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.group_by_air_boundary_adjacency"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_air_boundary_adjacency">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">group_by_air_boundary_adjacency</span><span class="p">(</span><span class="n">rooms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together that share air boundaries.</span>

<span class="sd">        This is useful for understanding the radiant enclosures that will exist</span>
<span class="sd">        when a model is exported to EnergyPlus.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their air boundary adjacency.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of list with each sub-list containing Room2Ds that share adjacent</span>
<span class="sd">            air boundaries. If a Room has no air boundaries it will the the only</span>
<span class="sd">            item within its sub-list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_adjacency_grouping</span><span class="p">(</span>
            <span class="n">rooms</span><span class="p">,</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_find_adjacent_air_boundary_rooms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Room2D.join_by_boundary"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_by_boundary">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">join_by_boundary</span><span class="p">(</span>
            <span class="n">room_2ds</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">hole_polygons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">identifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Join several Room2D together using a boundary Polygon as a guide.</span>

<span class="sd">        All properties of segments along the boundary polygon will be preserved.</span>
<span class="sd">        The largest Room2D that is identified within the boundary polygon will</span>
<span class="sd">        determine the extension properties of the resulting Room unless the supplied</span>
<span class="sd">        identifier matches an existing Room2D inside the polygon. All skylights</span>
<span class="sd">        will be lost.</span>

<span class="sd">        It is recommended that the Room2Ds be aligned to the boundaries</span>
<span class="sd">        of the polygon and duplicate vertices be removed before passing them</span>
<span class="sd">        through this method. This helps ensure that relevant Room2D segments</span>
<span class="sd">        are colinear with the polygon and so they can influence the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds which will be joined together using the polygon.</span>
<span class="sd">            polygon: A ladybug_geometry Polygon2D which will become the boundary</span>
<span class="sd">                of the output joined Room2D.</span>
<span class="sd">            hole_polygons: An optional list of hole polygons, which will add</span>
<span class="sd">                holes into the output joined Room2D polygon.</span>
<span class="sd">            floor_to_ceiling_height: An optional number to set the floor-to-ceiling</span>
<span class="sd">                height of the resulting Room2D. If None, it will be the maximum</span>
<span class="sd">                of the Room2Ds that are found inside the polygon, which ensures</span>
<span class="sd">                that all window geometries are included in the output. If specified</span>
<span class="sd">                and it is lower than the maximum Room2D height, any detailed</span>
<span class="sd">                windows will be automatically trimmed to accommodate the new</span>
<span class="sd">                floor-to-ceiling height. (Default: None).</span>
<span class="sd">            identifier: An optional text string for the identifier of the new</span>
<span class="sd">                joined Room2D. If this matches an existing Room2D inside of the</span>
<span class="sd">                polygon, the existing Room2D will be used to set the extension</span>
<span class="sd">                properties of the output Room2D. If None, the identifier</span>
<span class="sd">                and extension properties of the output Room2D will be those of</span>
<span class="sd">                the largest Room2D found inside of the polygon. (Default: None).</span>
<span class="sd">            display_name: An optional text string for the display_name of the new</span>
<span class="sd">                joined Room2D. If None, the display_name will be taken from the</span>
<span class="sd">                largest existing Room2D inside the polygon or the existing</span>
<span class="sd">                Room2D matching the identifier above. (Default: None).</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the polygon</span>
<span class="sd">                boundary at which point the vertex is considered to lie on the</span>
<span class="sd">                polygon. (Default: 0.01, suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="c1"># ensure that all polygons are counterclockwise</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_clockwise</span> <span class="k">else</span> <span class="n">polygon</span>
        <span class="k">if</span> <span class="n">hole_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cc_hole_polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hole_polygons</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_clockwise</span> <span class="k">else</span> <span class="n">p</span>
                <span class="n">cc_hole_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">hole_polygons</span> <span class="o">=</span> <span class="n">cc_hole_polygons</span>

        <span class="c1"># identify all Room2Ds inside of the polygon</span>
        <span class="n">rel_rooms</span><span class="p">,</span> <span class="n">rel_ids</span><span class="p">,</span> <span class="n">rel_a</span><span class="p">,</span> <span class="n">rel_fh</span><span class="p">,</span> <span class="n">rel_ch</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">test_vec</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">is_convex</span><span class="p">:</span>
                <span class="n">rm_pt</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">center</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rm_pt_3d</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">_point_on_face</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
                <span class="n">rm_pt</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">rm_pt_3d</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rm_pt_3d</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_point_inside_bound_rect</span><span class="p">(</span><span class="n">rm_pt</span><span class="p">,</span> <span class="n">test_vec</span><span class="p">):</span>
                <span class="n">rel_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
                <span class="n">rel_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                <span class="n">rel_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_area</span><span class="p">)</span>
                <span class="n">rel_fh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
                <span class="n">rel_ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>

        <span class="c1"># if no rooms are inside the polygon, just return a dummy room from the polygon</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_rooms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">floor_height</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">)</span>
            <span class="n">ftc</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">)</span> \
                <span class="k">if</span> <span class="n">floor_to_ceiling_height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">floor_to_ceiling_height</span>
            <span class="n">bound_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">fh</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
            <span class="n">all_hole_verts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">hole_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_polygons</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">all_hole_verts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">hole_polygons</span><span class="p">:</span>
                    <span class="n">all_hole_verts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">fh</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hole</span><span class="o">.</span><span class="n">vertices</span><span class="p">])</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">all_hole_verts</span><span class="p">)</span>
            <span class="n">r_id</span> <span class="o">=</span> <span class="n">clean_and_id_string</span><span class="p">(</span><span class="s1">&#39;Room&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">identifier</span>
            <span class="k">return</span> <span class="n">Room2D</span><span class="p">(</span><span class="n">r_id</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="n">ftc</span><span class="p">)</span>

        <span class="c1"># determine the new floor heights using max/average across relevant rooms</span>
        <span class="n">new_flr_height</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rel_fh</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_fh</span><span class="p">)</span>
        <span class="n">max_ftc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rel_ch</span><span class="p">)</span>
        <span class="n">new_ftc</span> <span class="o">=</span> <span class="n">max_ftc</span> <span class="k">if</span> <span class="n">floor_to_ceiling_height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">floor_to_ceiling_height</span>

        <span class="c1"># determine a primary room to set help set properties or the resulting room</span>
        <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">identifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rel_ids</span><span class="p">:</span>
            <span class="c1"># find the largest room of the relevant rooms</span>
            <span class="n">sort_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rel_a</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rel_a</span><span class="p">))))]</span>
            <span class="n">primary_room</span> <span class="o">=</span> <span class="n">rel_rooms</span><span class="p">[</span><span class="n">sort_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">identifier</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">identifier</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># draw properties from the room with the matching identifier</span>
            <span class="k">for</span> <span class="n">r_id</span><span class="p">,</span> <span class="n">rm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rel_ids</span><span class="p">,</span> <span class="n">rel_rooms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">r_id</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">:</span>
                    <span class="n">primary_room</span> <span class="o">=</span> <span class="n">rm</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">display_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">display_name</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">display_name</span>

        <span class="c1"># gather all segments and properties of relevant rooms</span>
        <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rel_rooms</span><span class="p">:</span>
            <span class="n">rel_segs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">)</span>
            <span class="n">rel_bcs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">)</span>
            <span class="n">rel_shd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">shading_parameters</span><span class="p">)</span>
            <span class="n">rel_abs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">air_boundaries</span><span class="p">)</span>
            <span class="n">w_par</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">window_parameters</span>
            <span class="n">in_range</span> <span class="o">=</span> <span class="n">new_ftc</span> <span class="o">-</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">&lt;</span> <span class="n">new_ftc</span> <span class="o">+</span> <span class="n">tol</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_range</span><span class="p">:</span>  <span class="c1"># adjust window ratios to preserve area</span>
                <span class="n">new_w_par</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w_par</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">SimpleWindowRatio</span><span class="p">):</span>
                        <span class="n">w_area</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span>
                            <span class="n">rel_segs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                        <span class="n">new_ratio</span> <span class="o">=</span> <span class="n">w_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">new_ftc</span> <span class="o">*</span> <span class="n">rel_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                        <span class="n">new_wp</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                        <span class="n">new_wp</span><span class="o">.</span><span class="n">_window_ratio</span> <span class="o">=</span> <span class="n">new_ratio</span> <span class="k">if</span> <span class="n">new_ratio</span> <span class="o">&lt;=</span> <span class="mf">0.99</span> <span class="k">else</span> <span class="mf">0.99</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wp</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                <span class="n">w_par</span> <span class="o">=</span> <span class="n">new_w_par</span>
            <span class="n">rel_win</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">w_par</span><span class="p">)</span>

        <span class="c1"># find all of the Room2Ds segments that lie on each polygon segment</span>
        <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">bound_verts</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_segments_along_polygon</span><span class="p">(</span>
            <span class="n">polygon</span><span class="p">,</span> <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span><span class="p">,</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hole_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_polygons</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_hole_verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">hole_polygons</span><span class="p">:</span>
                <span class="n">hole_verts</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_segments_along_polygon</span><span class="p">(</span>
                    <span class="n">hole</span><span class="p">,</span> <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span><span class="p">,</span>
                    <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                <span class="n">all_hole_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole_verts</span><span class="p">)</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">all_hole_verts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">)</span>

        <span class="c1"># merge all segments and properties into a single Room2D</span>
        <span class="n">new_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
            <span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="n">new_ftc</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span>
            <span class="n">primary_room</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">display_name</span> <span class="o">=</span> <span class="n">display_name</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="n">primary_room</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="c1"># TODO: Consider merging skylights and adding them to the new room</span>

        <span class="c1"># if the floor-to-ceiling height is lower than the max, re-trim windows</span>
        <span class="k">if</span> <span class="n">new_ftc</span> <span class="o">&lt;</span> <span class="n">max_ftc</span><span class="p">:</span>
            <span class="n">new_w_pars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">zip_items</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">new_room</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span>
                <span class="n">new_room</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span>
                <span class="n">new_room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">w_par</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zip_items</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w_par</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                    <span class="n">new_w_par</span> <span class="o">=</span> <span class="n">w_par</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">new_ftc</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_w_par</span> <span class="o">=</span> <span class="n">w_par</span>
                <span class="n">new_w_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_w_par</span><span class="p">)</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_w_pars</span>

        <span class="k">return</span> <span class="n">new_room</span></div>

<div class="viewcode-block" id="Room2D.floor_segment_by_index"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_segment_by_index">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">floor_segment_by_index</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">segment_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a particular LineSegment3D from a Face3D object.</span>

<span class="sd">        The logic applied by this method to select the segment is the same that is</span>
<span class="sd">        used to assign lists of values to the floor_geometry (eg. boundary conditions).</span>

<span class="sd">        Args:</span>
<span class="sd">            geometry: A Face3D representing floor geometry.</span>
<span class="sd">            segment_index: An integer for the index of the segment to return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> \
            <span class="kc">None</span> <span class="k">else</span> <span class="n">geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">geometry</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">segs</span><span class="p">[</span><span class="n">segment_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Room2D.join_floor_geometries"><a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_floor_geometries">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">join_floor_geometries</span><span class="p">(</span><span class="n">floor_faces</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Join a list of Face3Ds together to get as few as possible at the floor_height.</span>

<span class="sd">        Args:</span>
<span class="sd">            floor_faces: A list of Face3D objects to be joined together.</span>
<span class="sd">            floor_height: a number for the floor_height of the resulting horizontal</span>
<span class="sd">                Face3Ds.</span>
<span class="sd">            tolerance: The maximum difference between values at which point vertices</span>
<span class="sd">                are considered to be the same.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of horizontal Face3Ds for the minimum number joined together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># join all of the floor geometries into a single Polyface3D</span>
        <span class="n">room_floors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fg</span> <span class="ow">in</span> <span class="n">floor_faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fg</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">floor_height</span> <span class="o">-</span> <span class="n">fg</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">room_floors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># project the face geometry into the XY plane</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">fg</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">fg</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                    <span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">fg</span><span class="o">.</span><span class="n">holes</span><span class="p">]</span>
                <span class="n">room_floors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">holes</span><span class="p">))</span>
        <span class="n">flr_pf</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">room_floors</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># convert the Polyface3D into as few Face3Ds as possible</span>
        <span class="n">flr_pl</span> <span class="o">=</span> <span class="n">Polyline3D</span><span class="o">.</span><span class="n">join_segments</span><span class="p">(</span><span class="n">flr_pf</span><span class="o">.</span><span class="n">naked_edges</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flr_pl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># can be represented with a single Face3D</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">(</span><span class="n">flr_pl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># need to separate holes from distinct Face3Ds</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">pl</span> <span class="ow">in</span> <span class="n">flr_pl</span><span class="p">]</span>
            <span class="n">faces</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">base_face</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">remain_faces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

            <span class="n">all_face3ds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">remain_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">all_face3ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Room2D</span><span class="o">.</span><span class="n">_match_holes_to_face</span><span class="p">(</span>
                    <span class="n">base_face</span><span class="p">,</span> <span class="n">remain_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remain_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">base_face</span> <span class="o">=</span> <span class="n">remain_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">remain_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">remain_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># lone last Face3D</span>
                    <span class="n">all_face3ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">remain_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">remain_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">all_face3ds</span></div>

    <span class="k">def</span> <span class="nf">_room_volume_with_roof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roof_spec</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Polyface3D for the Room volume given a roof_spec above the room.</span>

<span class="sd">        Args:</span>
<span class="sd">            roof_spec: A Dragonfly RoofSpecification that describes the Roof</span>
<span class="sd">                above the room geometry.</span>
<span class="sd">            tolerance: The minimum distance from roof polygon edges at which a</span>
<span class="sd">                point is considered to lie on the edge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with the two items below.</span>

<span class="sd">            * room_polyface -- A Polyface3D object for the Room volume. This will</span>
<span class="sd">                be None whenever the Room has no Roof geometries above it or there</span>
<span class="sd">                are gaps or overlaps in the Roof geometries above the room.</span>

<span class="sd">            * roof_face_i -- A list of integers for the indices of the faces in</span>
<span class="sd">                the Polyface3D that correspond to the roof. Will be None whenever</span>
<span class="sd">                the roof is not successfully applied to the Room.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the roof polygons and the bounding Room2D polygon</span>
        <span class="n">roof_polys</span> <span class="o">=</span> <span class="n">roof_spec</span><span class="o">.</span><span class="n">boundary_geometry_2d</span>
        <span class="n">roof_planes</span> <span class="o">=</span> <span class="n">roof_spec</span><span class="o">.</span><span class="n">planes</span>
        <span class="n">room_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>

        <span class="c1"># gather all of the relevant roof polygons for the Room2D</span>
        <span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">,</span> <span class="n">is_full_bound</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">roof_polys</span><span class="p">,</span> <span class="n">roof_planes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span><span class="n">rf_py</span><span class="p">,</span> <span class="n">room_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="n">poly_rel</span> <span class="o">=</span> <span class="n">rf_py</span><span class="o">.</span><span class="n">polygon_relationship</span><span class="p">(</span><span class="n">room_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">poly_rel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">rel_rf_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_py</span><span class="p">)</span>
                    <span class="n">rel_rf_planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_pl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">poly_rel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># simple solution of one roof</span>
                    <span class="n">is_full_bound</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

        <span class="c1"># make the room volume</span>
        <span class="n">proj_dir</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># direction to project onto Roof planes</span>
        <span class="n">p_faces</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()]</span>  <span class="c1"># a list of Room volume faces</span>

        <span class="c1"># when fully bounded, simply project the segments onto the single Roof face</span>
        <span class="k">if</span> <span class="n">is_full_bound</span><span class="p">:</span>
            <span class="n">roof_plane</span> <span class="o">=</span> <span class="n">rel_rf_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">roof_verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">:</span>
                <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">roof_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">)</span>
                <span class="n">p4</span> <span class="o">=</span> <span class="n">roof_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">)</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">)))</span>
                <span class="n">roof_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p4</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">roof_verts</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
                <span class="n">part_roof_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">roof_verts</span><span class="p">[:</span><span class="n">v_count</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                    <span class="n">part_roof_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roof_verts</span><span class="p">[</span><span class="n">v_count</span><span class="p">:</span><span class="n">v_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)])</span>
                    <span class="n">v_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">part_roof_verts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">holes</span><span class="o">=</span><span class="n">part_roof_verts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">return</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># when multiple roofs, each segment must be intersected with the roof polygons</span>
        <span class="c1"># gather polygons that account for all of the Room2D holes</span>
        <span class="n">all_room_poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">room_poly</span><span class="p">]</span>
        <span class="n">flr_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">v_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_poly</span><span class="p">)</span>
            <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">flr_segs</span><span class="p">[:</span><span class="n">v_count</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">hole_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">])</span>
                <span class="n">all_room_poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole_poly</span><span class="p">)</span>
                <span class="n">all_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flr_segs</span><span class="p">[</span><span class="n">v_count</span><span class="p">:</span><span class="n">v_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)])</span>
                <span class="n">v_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">flr_segs</span><span class="p">]</span>
        <span class="c1"># loop through holes and boundary polygons and generate walls from them</span>
        <span class="k">for</span> <span class="n">rm_poly</span><span class="p">,</span> <span class="n">rm_segs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_room_poly</span><span class="p">,</span> <span class="n">all_segments</span><span class="p">):</span>
            <span class="c1"># find the polygon that the first room vertex is located in</span>
            <span class="n">current_poly</span><span class="p">,</span> <span class="n">current_plane</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span> <span class="o">=</span> <span class="n">rel_rf_polys</span><span class="p">[:],</span> <span class="n">rel_rf_planes</span><span class="p">[:]</span>  <span class="c1"># copy lists</span>
            <span class="n">pt1</span> <span class="o">=</span> <span class="n">rm_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">rf_py</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">current_poly</span><span class="p">,</span> <span class="n">current_plane</span> <span class="o">=</span> <span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span>
                    <span class="n">other_poly</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">other_planes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">current_poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># first point not inside a roof, invalid roof</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="c1"># loop through segments and add vertices if they cross outside the roof face</span>
            <span class="n">rot_poly</span> <span class="o">=</span> <span class="n">rm_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rot_poly</span><span class="p">,</span> <span class="n">rm_segs</span><span class="p">):</span>
                <span class="n">face_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">]</span>
                <span class="c1"># see if the segment ends in the same face it starts in</span>
                <span class="k">if</span> <span class="n">current_poly</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># project seg</span>
                    <span class="n">face_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">))</span>
                    <span class="n">face_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">int_pts</span><span class="p">,</span> <span class="n">int_pls</span> <span class="o">=</span> <span class="p">[(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">current_plane</span><span class="p">]</span>
                    <span class="c1"># find where the segment leaves the polygon</span>
                    <span class="n">seg_2d</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_array</span><span class="p">(((</span><span class="n">pt1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">pt2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt2</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">rf_seg</span> <span class="ow">in</span> <span class="n">current_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                        <span class="n">int_pt</span> <span class="o">=</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">rf_seg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">dist</span><span class="p">,</span> <span class="n">cls_pts</span> <span class="o">=</span> <span class="n">closest_point2d_between_line2d</span><span class="p">(</span>
                                <span class="n">seg_2d</span><span class="p">,</span> <span class="n">rf_seg</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                <span class="n">int_pt</span> <span class="o">=</span> <span class="n">cls_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">int_pt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                            <span class="n">int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="p">)</span>
                    <span class="c1"># find where it intersects the other relevant polygons</span>
                    <span class="k">for</span> <span class="n">o_poly</span><span class="p">,</span> <span class="n">o_pl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">o_seg</span> <span class="ow">in</span> <span class="n">o_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                            <span class="n">int_pt</span> <span class="o">=</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">o_seg</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">,</span> <span class="n">cls_pts</span> <span class="o">=</span> <span class="n">closest_point2d_between_line2d</span><span class="p">(</span>
                                    <span class="n">seg_2d</span><span class="p">,</span> <span class="n">o_seg</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                    <span class="n">int_pt</span> <span class="o">=</span> <span class="n">cls_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">int_pt</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                                <span class="n">int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o_pl</span><span class="p">)</span>
                    <span class="c1"># project the points and sort the intersections along the segment</span>
                    <span class="n">rf_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">ipl</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">proj_dir</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">ipl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">int_pts</span><span class="p">,</span> <span class="n">int_pls</span><span class="p">)]</span>
                    <span class="n">pt_dists</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                                <span class="k">for</span> <span class="n">ipt</span> <span class="ow">in</span> <span class="n">int_pts</span><span class="p">]</span>
                    <span class="n">sort_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pt_dists</span><span class="p">,</span> <span class="n">rf_pts</span><span class="p">))]</span>
                    <span class="c1"># add a vertex for where the segment ends in the polygon</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">rf_py</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">other_poly</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">other_poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_poly</span><span class="p">)</span>
                            <span class="n">other_planes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">other_planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="p">)</span>
                            <span class="n">current_poly</span><span class="p">,</span> <span class="n">current_plane</span> <span class="o">=</span> <span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span>
                            <span class="n">sort_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">rf_pl</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">pt2</span><span class="p">),</span> <span class="n">proj_dir</span><span class="p">))</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">current_poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># point not inside a roof, invalid roof</span>
                        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                    <span class="c1"># remove duplicated vertices from the list and add to the Face3D</span>
                    <span class="n">sort_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sort_pts</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">pt</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">sort_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)]</span>
                    <span class="n">sort_pts</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="n">face_pts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sort_pts</span><span class="p">)</span>
                <span class="c1"># make the final Face3D</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># second point not inside a roof, invalid roof</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">face_pts</span><span class="p">))</span>
                <span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span>  <span class="c1"># increment for next segment</span>

        <span class="c1"># add the roof faces using polygon boolean operations</span>
        <span class="c1"># create the BooleanPolygons for the Room2D and each relevant Roof polygon</span>
        <span class="n">room_polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rom_poly</span> <span class="ow">in</span> <span class="n">all_room_poly</span><span class="p">:</span>
            <span class="n">room_polys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pb</span><span class="o">.</span><span class="n">BooleanPoint</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">rom_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
        <span class="n">b_room_poly</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">BooleanPolygon</span><span class="p">(</span><span class="n">room_polys</span><span class="p">)</span>
        <span class="n">b_roof_polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rf_poly</span> <span class="ow">in</span> <span class="n">rel_rf_polys</span><span class="p">:</span>
            <span class="n">rf_pts</span> <span class="o">=</span> <span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">BooleanPoint</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">rf_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">b_roof_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">BooleanPolygon</span><span class="p">([</span><span class="n">rf_pts</span><span class="p">]))</span>
        <span class="c1"># find the boolean intersection with each roof polygon and project the result</span>
        <span class="n">roof_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b_rf_poly</span><span class="p">,</span> <span class="n">rf_plane</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b_roof_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">):</span>
            <span class="n">int_result</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">b_room_poly</span><span class="p">,</span> <span class="n">b_rf_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon2D</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">new_poly</span><span class="p">))</span>
                     <span class="k">for</span> <span class="n">new_poly</span> <span class="ow">in</span> <span class="n">int_result</span><span class="o">.</span><span class="n">regions</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># sort the polygons by area and check if any are inside the others</span>
                <span class="n">polys</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">poly_groups</span> <span class="o">=</span> <span class="p">[[</span><span class="n">polys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
                <span class="k">for</span> <span class="n">sub_poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poly_groups</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">pg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_polygon_inside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">):</span>  <span class="c1"># it&#39;s a hole</span>
                            <span class="n">poly_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s a separate Face3D</span>
                        <span class="n">poly_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sub_poly</span><span class="p">])</span>
                <span class="c1"># convert all vertices to 3D and append the roof Face3D</span>
                <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="n">poly_groups</span><span class="p">:</span>
                    <span class="n">pg_3d</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">shp</span> <span class="ow">in</span> <span class="n">pg</span><span class="p">:</span>
                        <span class="n">pt3s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="n">rf_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">pt2</span><span class="p">),</span> <span class="n">proj_dir</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">shp</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                        <span class="n">pg_3d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt3s</span><span class="p">)</span>
                    <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pg_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rf_plane</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">pg_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no holes are possible in the result; project all polygons directly</span>
                <span class="k">for</span> <span class="n">sub_poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
                    <span class="n">pt3s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">rf_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">pt2</span><span class="p">),</span> <span class="n">proj_dir</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">sub_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pt3s</span><span class="p">,</span> <span class="n">rf_plane</span><span class="p">))</span>
        <span class="n">roof_face_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">roof_faces</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">p_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">roof_faces</span><span class="p">)</span>

        <span class="c1"># create the Polyface3D and try to cap it with vertical faces if it is not solid</span>
        <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
            <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">merge_overlapping_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">ed</span> <span class="k">for</span> <span class="n">ed</span> <span class="ow">in</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">naked_edges</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="n">ed</span><span class="o">.</span><span class="n">is_vertical</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)]</span>
            <span class="n">vertical_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                <span class="n">e1p1</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">e1p2</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">edge_2</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">e2p1</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                        <span class="n">e2p2</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">e1p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">e2p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">and</span> \
                                <span class="n">e1p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">e2p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                            <span class="n">new_face3d</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">))</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
                                <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">f_poly</span> <span class="o">=</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">polygon2d</span>
                                <span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">f_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                                <span class="n">int_pt</span> <span class="o">=</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span>
                                    <span class="n">fs1</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">fs2</span><span class="p">))</span>
                                <span class="n">new_face3d1</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">((</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">int_pt</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">))</span>
                                <span class="n">new_face3d2</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">((</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">int_pt</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">))</span>
                                <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d1</span><span class="p">)</span>
                                <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d2</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">e1p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">e2p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">and</span> \
                                <span class="n">e1p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">e2p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                            <span class="n">new_face3d</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">))</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
                                <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">f_poly</span> <span class="o">=</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">polygon2d</span>
                                <span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">f_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                                <span class="n">int_pt</span> <span class="o">=</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span>
                                    <span class="n">fs1</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">fs2</span><span class="p">))</span>
                                <span class="n">new_face3d1</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">((</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">int_pt</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">))</span>
                                <span class="n">new_face3d2</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">((</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">int_pt</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">))</span>
                                <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d1</span><span class="p">)</span>
                                <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d2</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># we have reached the end of the list</span>
            <span class="n">st_v</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">roof_face_i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">roof_face_i</span> <span class="o">=</span> <span class="n">roof_face_i</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">st_v</span><span class="p">,</span> <span class="n">st_v</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertical_faces</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">p_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vertical_faces</span><span class="p">)</span>
            <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span>

    <span class="k">def</span> <span class="nf">_honeybee_plenums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hb_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get ceiling and/or floor plenums for the Room2D as a Honeybee Room.</span>

<span class="sd">        This method will check if there is a gap between the Room2D&#39;s ceiling and</span>
<span class="sd">        floor, and the top and bottom of it&#39;s corresponding Story, respectively.</span>
<span class="sd">        If there is a gap along the z axis larger then the specified tolerance,</span>
<span class="sd">        it will compute the necessary ceiling and/or floor plenum to fill the gap.</span>

<span class="sd">        Args:</span>
<span class="sd">            hb_room: A honeybee Room representing the dragonfly Room2D.</span>
<span class="sd">            tolerance: The minimum distance in z values to check if the Room ceiling</span>
<span class="sd">                and floor is adjacent to the upper and lower floor of the Story,</span>
<span class="sd">                respectively. If not adjacent, the corresponding ceiling or floor</span>
<span class="sd">                plenum is generated. Default: 0.01, suitable for objects in meters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Honeybee Rooms with two items:</span>

<span class="sd">                * ceil_plenum -- A honeybee-core Room representing the ceiling</span>
<span class="sd">                    plenum. If there isn&#39;t enough space between the Story</span>
<span class="sd">                    floor_to_floor_height and the Room2D floor_to_ceiling height,</span>
<span class="sd">                    this item will be None.</span>

<span class="sd">                * floor_plenum -- A honeybee-core Room representing the floor plenum.</span>
<span class="sd">                    If there isn&#39;t enough space between the Story floor_height and</span>
<span class="sd">                    the Room2D floor_height, this item will be None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check to be sure that the room2d has a parent story</span>
        <span class="n">hb_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s1">&#39;Cannot add plenums to the &quot;</span><span class="si">{}</span><span class="s1">&quot; Room because the parent Story has &#39;</span>
                <span class="s1">&#39;not been set. This is required to derive the plenum &#39;</span>
                <span class="s1">&#39;height.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">parent_ceiling</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">+</span> <span class="n">parent</span><span class="o">.</span><span class="n">floor_to_floor_height</span>
        <span class="n">ceil_plenum_height</span> <span class="o">=</span> <span class="n">parent_ceiling</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span>
        <span class="n">floor_plenum_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">-</span> <span class="n">parent</span><span class="o">.</span><span class="n">floor_height</span>

        <span class="k">if</span> <span class="n">ceil_plenum_height</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">ceil_plenum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_honeybee_plenum</span><span class="p">(</span>
                <span class="n">ceil_plenum_height</span><span class="p">,</span> <span class="n">plenum_type</span><span class="o">=</span><span class="s2">&quot;ceiling&quot;</span><span class="p">)</span>
            <span class="c1"># Set the plenum and the rooms to be adjacent to one another</span>
            <span class="n">hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_adjacency</span><span class="p">(</span><span class="n">ceil_plenum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">hb_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ceil_plenum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">floor_plenum_height</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">floor_plenum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_honeybee_plenum</span><span class="p">(</span>
                <span class="n">floor_plenum_height</span><span class="p">,</span> <span class="n">plenum_type</span><span class="o">=</span><span class="s2">&quot;floor&quot;</span><span class="p">)</span>
            <span class="c1"># Set the plenum and the rooms to be adjacent to one another</span>
            <span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_adjacency</span><span class="p">(</span><span class="n">floor_plenum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">hb_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">floor_plenum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hb_rooms</span>

    <span class="k">def</span> <span class="nf">_honeybee_plenum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plenum_height</span><span class="p">,</span> <span class="n">plenum_type</span><span class="o">=</span><span class="s1">&#39;ceiling&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a ceiling or floor plenum for the Room2D as a Honeybee Room.</span>

<span class="sd">        The boundary condition for all plenum faces is adiabatic except for the</span>
<span class="sd">        ceiling and floor surfaces between the room, and any outdoor walls.</span>

<span class="sd">        Args:</span>
<span class="sd">            hb_room: A honeybee Room representing the dragonfly Room2D.</span>
<span class="sd">            plenum_height: The height of the plenum Room.</span>
<span class="sd">            plenum_type: Text for the type of plenum to be constructed.</span>
<span class="sd">                Choose from the following:</span>

<span class="sd">                * ceiling</span>
<span class="sd">                * floor</span>

<span class="sd">        Returns:</span>
<span class="sd">            A honeybee Room representing a plenum zone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plenum_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">_plenum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">plenum_type</span><span class="p">)</span>

        <span class="c1"># create reference 2d geometry for plenums</span>
        <span class="n">ref_face3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">plenum_type</span> <span class="o">==</span> <span class="s1">&#39;ceiling&#39;</span><span class="p">:</span>
            <span class="n">ref_face3d</span> <span class="o">=</span> <span class="n">ref_face3d</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_face3d</span> <span class="o">=</span> <span class="n">ref_face3d</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">plenum_height</span><span class="p">))</span>

        <span class="c1"># create the honeybee Room</span>
        <span class="n">plenum_hb_room</span> <span class="o">=</span> <span class="n">Room</span><span class="o">.</span><span class="n">from_polyface3d</span><span class="p">(</span>
            <span class="n">plenum_id</span><span class="p">,</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_offset_face</span><span class="p">(</span><span class="n">ref_face3d</span><span class="p">,</span> <span class="n">plenum_height</span><span class="p">))</span>

        <span class="c1"># get the boundary condition that will be used for interior surfaces</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">interior_bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># honeybee_energy is not loaded; no Adiabatic BC</span>
            <span class="n">interior_bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>

        <span class="c1"># assign wall BCs based on self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">plenum_hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bc</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># assign boundary conditions for the roof and floor</span>
                <span class="n">plenum_hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">interior_bc</span>

        <span class="k">if</span> <span class="n">plenum_type</span> <span class="o">==</span> <span class="s1">&#39;ceiling&#39;</span><span class="p">:</span>  <span class="c1"># assign ceiling BCs</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span><span class="p">:</span>
                <span class="n">plenum_hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plenum_hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">interior_bc</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># assign floor BCss</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span><span class="p">:</span>
                <span class="n">plenum_hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plenum_hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">interior_bc</span>

        <span class="k">return</span> <span class="n">plenum_hb_room</span>

    <span class="k">def</span> <span class="nf">_match_and_transfer_wall_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transfer wall properties for matching segments between this room and another.</span>

<span class="sd">        This includes boundary conditions, window/shading parameters, and the</span>
<span class="sd">        air boundary property.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_room: An other Room2D to which wall properties will be transferred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build up new lists of parameters if the segments match</span>
        <span class="n">exist_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
        <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg1</span> <span class="ow">in</span> <span class="n">other_room</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>  <span class="c1"># a match!</span>
                        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># the segment could not be matched</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">other_room</span><span class="o">.</span><span class="n">boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
        <span class="n">other_room</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_win</span>
        <span class="n">other_room</span><span class="o">.</span><span class="n">shading_parameters</span> <span class="o">=</span> <span class="n">new_shd</span>
        <span class="n">other_room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>

    <span class="k">def</span> <span class="nf">_check_wall_assigned_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">obj_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check an input that gets assigned to all of the walls of the Room.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input </span><span class="si">{}</span><span class="s1"> must be a list or a tuple&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj_name</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s1">&#39;Input </span><span class="si">{}</span><span class="s1"> length must be the &#39;</span> \
            <span class="s1">&#39;same as the number of floor_segments. </span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">obj_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_flip_wall_assigned_objects</span><span class="p">(</span><span class="n">original_geo</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">shd_pars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get arrays of wall-assigned parameters that are flipped/reversed.</span>

<span class="sd">        This method accounts for the case that a floor geometry has holes in it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># go through the boundary and ensure detailed parameters are flipped</span>
        <span class="n">new_bcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_win_pars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">original_geo</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">):</span>
            <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">win_par</span> <span class="o">=</span> <span class="n">win_pars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="p">)</span>
            <span class="n">new_shd_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd_pars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># reverse the lists of wall-assigned objects on the floor boundary</span>
        <span class="n">new_bcs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">new_win_pars</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">new_shd_pars</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="c1"># add any objects related to the holes</span>
        <span class="k">if</span> <span class="n">original_geo</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">bound_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
            <span class="n">new_bcs</span> <span class="o">=</span> <span class="n">new_bcs</span> <span class="o">+</span> <span class="n">bcs</span><span class="p">[</span><span class="n">bound_len</span><span class="p">:]</span>
            <span class="n">new_win_pars</span> <span class="o">=</span> <span class="n">new_win_pars</span> <span class="o">+</span> <span class="n">win_pars</span><span class="p">[</span><span class="n">bound_len</span><span class="p">:]</span>
            <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="n">new_shd_pars</span> <span class="o">+</span> <span class="n">shd_pars</span><span class="p">[</span><span class="n">bound_len</span><span class="p">:]</span>

        <span class="c1"># return the flipped lists</span>
        <span class="k">return</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win_pars</span><span class="p">,</span> <span class="n">new_shd_pars</span>

    <span class="k">def</span> <span class="nf">_split_walls_along_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hb_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">plenums</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split adjacent walls to ensure matching surface areas in to_honeybee workflow.</span>

<span class="sd">        Args:</span>
<span class="sd">            hb_room: A non-split Honeybee Room representation of this Room2D.</span>
<span class="sd">            tolerance: The minimum distance in z values of floor_height and</span>
<span class="sd">                floor_to_ceiling_height at which adjacent Faces will be split.</span>
<span class="sd">            plenums: A boolean to note whether the resulting model has auto-generated</span>
<span class="sd">                plenums, which will determine the default boundary condition of</span>
<span class="sd">                any split wall segments. (Default: False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">adj_rm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">room_by_identifier</span><span class="p">(</span>
                        <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># missing adjacency in Story; just pass invalid BC</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">flr_diff</span> <span class="o">=</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span>
                <span class="n">ciel_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span> <span class="o">-</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">ceiling_height</span>
                <span class="k">if</span> <span class="n">flr_diff</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> <span class="n">ciel_diff</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># No need to split the surface along its height</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">flr_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span> <span class="ow">and</span> <span class="n">ciel_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># split the face into to 3 smaller faces along its height</span>
                    <span class="n">lseg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span> <span class="o">-</span> <span class="n">flr_diff</span>
                    <span class="n">vec1</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flr_diff</span><span class="p">)</span>
                    <span class="n">vec2</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span><span class="p">)</span>
                    <span class="n">below</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">vec1</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">))</span>
                    <span class="n">above</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec2</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ciel_diff</span><span class="p">))</span>
                    <span class="n">mid_face</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                    <span class="n">mid_face</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_split_windows</span><span class="p">(</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">below_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Below&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">below</span><span class="p">)</span>
                    <span class="n">above_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Above&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">above</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span> \
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">plenums</span> <span class="k">else</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># honeybee_energy is not loaded; no adiabatic BC</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span> \
                            <span class="k">if</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">plenums</span> <span class="k">else</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># honeybee_energy is not loaded; no adiabatic BC</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">below_face</span><span class="p">,</span> <span class="n">mid_face</span><span class="p">,</span> <span class="n">above_face</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">flr_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># split the face into to 2 smaller faces along its height</span>
                    <span class="n">lseg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">flr_diff</span>
                    <span class="n">vec1</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flr_diff</span><span class="p">)</span>
                    <span class="n">below</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">vec1</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">))</span>
                    <span class="n">mid_face</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                    <span class="n">mid_face</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_split_windows</span><span class="p">(</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">below_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Below&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">below</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span> \
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">plenums</span> <span class="k">else</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># honeybee_energy is not loaded; no adiabatic BC</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">below_face</span><span class="p">,</span> <span class="n">mid_face</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">ciel_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># split the face into to 2 smaller faces along its height</span>
                    <span class="n">lseg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span>
                    <span class="n">vec1</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">vec1</span><span class="p">)</span>
                    <span class="n">above</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ciel_diff</span><span class="p">))</span>
                    <span class="n">mid_face</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                    <span class="n">mid_face</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_split_windows</span><span class="p">(</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">above_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Above&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">above</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">above_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span> \
                            <span class="k">if</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">plenums</span> <span class="k">else</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># honeybee_energy is not loaded; no adiabatic BC</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">above_face</span><span class="p">])</span>
        <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_faces</span>

    <span class="k">def</span> <span class="nf">_reassign_split_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-assign WindowParameters to any base surface that has been split.</span>

<span class="sd">        Args:</span>
<span class="sd">            face: Honeybee Face to which windows will be re-assigned.</span>
<span class="sd">            i: The index of the window_parameters that correspond to the face</span>
<span class="sd">            tolerance: The tolerance, which will be used to re-assign windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glz_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">glz_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">face</span><span class="o">.</span><span class="n">remove_sub_faces</span><span class="p">()</span>
            <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_match_holes_to_face</span><span class="p">(</span><span class="n">base_face</span><span class="p">,</span> <span class="n">other_faces</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attempt to merge other faces into a base face as holes.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_face: A Face3D to serve as the base.</span>
<span class="sd">            other_faces: A list of other Face3D objects to attempt to merge into</span>
<span class="sd">                the base_face as a hole. This method will delete any faces</span>
<span class="sd">                that are successfully merged into the output from this list.</span>
<span class="sd">            tol: The tolerance to be used for evaluating sub-faces.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Face3D which has holes in it if any of the other_faces is a valid</span>
<span class="sd">            sub face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">more_to_check</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">more_to_check</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r_face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other_faces</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">base_face</span><span class="o">.</span><span class="n">is_sub_face</span><span class="p">(</span><span class="n">r_face</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_face</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">other_faces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">more_to_check</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">holes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base_face</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hole_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">hole</span><span class="o">.</span><span class="n">vertices</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">base_face</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">Plane</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">hole_verts</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_segment_wall_face</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Wall Face that corresponds with a certain wall segment.</span>

<span class="sd">        Args:</span>
<span class="sd">            room: A Honeybee Room from which a wall Face will be returned.</span>
<span class="sd">            segment: A LineSegment3D along one of the walls of the room.</span>
<span class="sd">            tolerance: The maximum difference between values at which point vertices</span>
<span class="sd">                are considered to be the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">Wall</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">)):</span>
                <span class="n">fg</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">geometry</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">verts</span> <span class="o">=</span> <span class="n">fg</span><span class="o">.</span><span class="n">_remove_colinear</span><span class="p">(</span>
                        <span class="n">fg</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">fg</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">p2</span>
                        <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                                <span class="k">return</span> <span class="n">face</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_remove_colinear_props</span><span class="p">(</span>
            <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove colinear vertices across a boundary while merging window properties.&quot;&quot;&quot;</span>
        <span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># track the number of vertices being skipped/removed</span>
        <span class="n">m_segs</span><span class="p">,</span> <span class="n">m_bcs</span><span class="p">,</span> <span class="n">m_w_par</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1"># loop through vertices and remove all cases of colinear verts</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">):</span>
            <span class="n">m_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segs_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">m_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound_cds</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">m_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_pars</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                <span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">_v</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tolerance</span><span class="p">:</span>  <span class="c1"># vertex is not colinear; add vertex and merge</span>
                <span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Ground</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">m_bcs</span><span class="p">):</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">wp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">m_w_par</span><span class="p">):</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_wp</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">,</span> <span class="n">m_segs</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">)</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wp</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">ground</span><span class="p">)</span>
                    <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">m_bcs</span><span class="p">,</span> <span class="n">m_w_par</span><span class="p">,</span> <span class="n">m_segs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># vertex is colinear; continue</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># catch case of last two vertices being equal but distinct from first point</span>
        <span class="k">if</span> <span class="n">skip</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pts_3d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                <span class="n">pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">pts_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bound_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">Ground</span><span class="p">):</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                    <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_pars</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">ground</span><span class="p">)</span>
                    <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># move the first properties to the end to match with the vertices</span>
        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_bcs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_w_par</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_adjacency_grouping</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">adj_finding_function</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together according to an adjacency finding function.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their adjacency.</span>
<span class="sd">            adj_finding_function: A function that denotes which rooms are adjacent</span>
<span class="sd">                to another.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of list with each sub-list containing rooms that share adjacencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a room lookup table and duplicate the list of rooms</span>
        <span class="n">room_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">rm</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">rm</span> <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">}</span>
        <span class="n">all_rooms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rooms</span><span class="p">)</span>
        <span class="n">adj_network</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through the rooms and find air boundary adjacencies</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">all_rooms</span><span class="p">:</span>
            <span class="n">adj_ids</span> <span class="o">=</span> <span class="n">adj_finding_function</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># a room that is its own solar enclosure</span>
                <span class="n">adj_network</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">room</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># there are other adjacent rooms to find</span>
                <span class="n">local_network</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span><span class="p">]</span>
                <span class="n">local_ids</span><span class="p">,</span> <span class="n">first_id</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adj_ids</span><span class="p">),</span> <span class="n">room</span><span class="o">.</span><span class="n">identifier</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># add the current rooms to the local network</span>
                    <span class="n">adj_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">room_lookup</span><span class="p">[</span><span class="n">rm_id</span><span class="p">]</span> <span class="k">for</span> <span class="n">rm_id</span> <span class="ow">in</span> <span class="n">adj_ids</span><span class="p">]</span>
                    <span class="n">local_network</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">adj_objs</span><span class="p">)</span>
                    <span class="n">adj_ids</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># reset the list of new adjacencies</span>
                    <span class="c1"># find any rooms that are adjacent to the adjacent rooms</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">adj_objs</span><span class="p">:</span>
                        <span class="n">all_new_ids</span> <span class="o">=</span> <span class="n">adj_finding_function</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                        <span class="n">new_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">rid</span> <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">all_new_ids</span>
                                   <span class="k">if</span> <span class="n">rid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">local_ids</span> <span class="ow">and</span> <span class="n">rid</span> <span class="o">!=</span> <span class="n">first_id</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">rm_id</span> <span class="ow">in</span> <span class="n">new_ids</span><span class="p">:</span>
                            <span class="n">local_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rm_id</span><span class="p">)</span>
                        <span class="n">adj_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_ids</span><span class="p">)</span>
                <span class="c1"># after the local network is understood, clean up duplicated rooms</span>
                <span class="n">adj_network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_network</span><span class="p">)</span>
                <span class="n">i_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_rooms</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">room_obj</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">local_ids</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">i_to_remove</span><span class="p">):</span>
                    <span class="n">all_rooms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adj_network</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_adjacent_rooms</span><span class="p">(</span><span class="n">room</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the identifiers of all rooms with adjacency to a room.&quot;&quot;&quot;</span>
        <span class="n">adj_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">adj_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">adj_rooms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_adjacent_air_boundary_rooms</span><span class="p">(</span><span class="n">room</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the identifiers of all rooms with air boundary adjacency to a room.&quot;&quot;&quot;</span>
        <span class="n">adj_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span> <span class="n">room</span><span class="o">.</span><span class="n">air_boundaries</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ab</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">adj_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">adj_rooms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_segments_along_polygon</span><span class="p">(</span>
            <span class="n">polygon</span><span class="p">,</span> <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span><span class="p">,</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the segments along a polygon and add their properties to new lists.&quot;&quot;&quot;</span>
        <span class="n">new_segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">seg_segs</span><span class="p">,</span> <span class="n">seg_bcs</span><span class="p">,</span> <span class="n">seg_win</span><span class="p">,</span> <span class="n">seg_shd</span><span class="p">,</span> <span class="n">seg_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="c1"># collect the room segments and properties along the boundary</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rel_segs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="ow">and</span> \
                        <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># colinear</span>
                    <span class="n">seg_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
                    <span class="n">seg_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">seg_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_win</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">seg_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_shd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">seg_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg_segs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Room2D</span><span class="o">.</span><span class="n">_add_dummy_segment</span><span class="p">(</span>
                    <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># sort the Room2D segments along the polygon segment</span>
            <span class="n">seg_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg_segs</span><span class="p">]</span>
            <span class="n">sort_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">seg_dists</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_dists</span><span class="p">))))]</span>
            <span class="n">seg_segs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_win</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_shd</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_shd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_abs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="c1"># identify any gaps and add dummy segments</span>
            <span class="n">p1_dists</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seg_dists</span><span class="p">)</span>
            <span class="n">p2_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg_segs</span><span class="p">]</span>
            <span class="n">last_d</span><span class="p">,</span> <span class="n">last_seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p1d</span><span class="p">,</span> <span class="n">p2d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p1_dists</span><span class="p">,</span> <span class="n">p2_dists</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">p1d</span> <span class="o">&lt;</span> <span class="n">last_d</span> <span class="o">-</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># overlapping segment; ignore it</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">p1d</span> <span class="o">&gt;</span> <span class="n">last_d</span> <span class="o">+</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># add a dummy segment for the gap</span>
                    <span class="n">st_pt</span> <span class="o">=</span> <span class="n">last_seg</span><span class="o">.</span><span class="n">p2</span> <span class="k">if</span> <span class="n">last_seg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span>
                    <span class="n">Room2D</span><span class="o">.</span><span class="n">_add_dummy_segment</span><span class="p">(</span>
                        <span class="n">st_pt</span><span class="p">,</span> <span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span>
                        <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">)</span>
                <span class="c1"># add the segment</span>
                <span class="n">new_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_win</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_shd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">last_d</span> <span class="o">=</span> <span class="n">p2d</span>
                <span class="n">last_seg</span> <span class="o">=</span> <span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_segs</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_dummy_segment</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a dummy segment to lists of properties that are being built.&quot;&quot;&quot;</span>
        <span class="n">new_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_intersect_line2d_infinite</span><span class="p">(</span><span class="n">line_ray_a</span><span class="p">,</span> <span class="n">line_ray_b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the intersection between a Ray2Ds extended infinitely.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_ray_a: A Ray2D object.</span>
<span class="sd">            line_ray_b: Another Ray2D object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point2D of intersection if it exists. None if lines are parallel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span>
        <span class="n">ua</span> <span class="o">=</span> <span class="p">(</span><span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">ua</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                       <span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">ua</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_r</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[:])</span>  <span class="c1"># copy boundary condition list</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[:]</span>  <span class="c1"># copy window list</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[:]</span>  <span class="c1"># copy shading list</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">[:]</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_is_ground_contact</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_is_top_exposed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_r</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Room2D: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2023, Ladybug Tools.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>